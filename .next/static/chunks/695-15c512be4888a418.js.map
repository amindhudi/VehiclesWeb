{"version":3,"file":"static/chunks/695-15c512be4888a418.js","mappings":"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","sources":["webpack://_N_E/../../src/client/add-locale.ts","webpack://_N_E/../../src/client/get-domain-locale.ts","webpack://_N_E/../../src/client/link.tsx","webpack://_N_E/../../src/client/request-idle-callback.ts","webpack://_N_E/../../src/client/resolve-href.ts","webpack://_N_E/../../src/client/use-intersection.tsx","webpack://_N_E/../../../src/shared/lib/escape-regexp.ts","webpack://_N_E/../../../src/shared/lib/router-context.shared-runtime.ts","webpack://_N_E/../../../src/shared/lib/router/utils/format-url.ts","webpack://_N_E/../../../src/shared/lib/router/utils/index.ts","webpack://_N_E/../../../src/shared/lib/router/utils/interpolate-as.ts","webpack://_N_E/../../../src/shared/lib/router/utils/is-dynamic.ts","webpack://_N_E/../../../src/shared/lib/router/utils/is-local-url.ts","webpack://_N_E/../../../src/shared/lib/router/utils/omit.ts","webpack://_N_E/../../../src/shared/lib/router/utils/querystring.ts","webpack://_N_E/../../../src/shared/lib/router/utils/route-matcher.ts","webpack://_N_E/../../../src/shared/lib/router/utils/route-regex.ts","webpack://_N_E/../../../src/shared/lib/router/utils/sorted-routes.ts","webpack://_N_E/../../../src/shared/lib/utils.ts","webpack://_N_E/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js","webpack://_N_E/./node_modules/use-sync-external-store/shim/index.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/focusManager.mjs","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/logger.mjs","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/mutation.mjs","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/notifyManager.mjs","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/onlineManager.mjs","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/removable.mjs","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/retryer.mjs","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/subscribable.mjs","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/utils.mjs","webpack://_N_E/../../src/QueryClientProvider.tsx","webpack://_N_E/./node_modules/@trpc/server/dist/observable-ade1bad8.mjs","webpack://_N_E/./node_modules/@trpc/server/dist/observable/index.mjs","webpack://_N_E/./node_modules/@trpc/client/dist/splitLink-4c75f7be.mjs","webpack://_N_E/./node_modules/@trpc/client/dist/transformResult-ace864b8.mjs","webpack://_N_E/./node_modules/@trpc/client/dist/TRPCClientError-38f9a32a.mjs","webpack://_N_E/./node_modules/@trpc/client/dist/httpUtils-b9d0cb48.mjs","webpack://_N_E/./node_modules/@trpc/client/dist/httpBatchLink-d0f9eac9.mjs","webpack://_N_E/./node_modules/@trpc/client/dist/links/httpLink.mjs","webpack://_N_E/./node_modules/@trpc/client/dist/links/loggerLink.mjs","webpack://_N_E/./node_modules/@trpc/client/dist/links/wsLink.mjs","webpack://_N_E/./node_modules/@trpc/client/dist/index.mjs","webpack://_N_E/./node_modules/@trpc/react-query/dist/getArrayQueryKey-86134f8b.mjs","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/queryObserver.mjs","webpack://_N_E/../../src/useSyncExternalStore.ts","webpack://_N_E/../../src/QueryErrorResetBoundary.tsx","webpack://_N_E/../../src/isRestoring.tsx","webpack://_N_E/./node_modules/@tanstack/react-query/build/lib/utils.mjs","webpack://_N_E/../../src/errorBoundaryUtils.ts","webpack://_N_E/./node_modules/@tanstack/react-query/build/lib/suspense.mjs","webpack://_N_E/../../src/useBaseQuery.ts","webpack://_N_E/../../src/useQuery.ts","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/mutationObserver.mjs","webpack://_N_E/../../src/useMutation.ts","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/infiniteQueryObserver.mjs","webpack://_N_E/../../src/useInfiniteQuery.ts","webpack://_N_E/./node_modules/@tanstack/query-core/build/lib/queriesObserver.mjs","webpack://_N_E/../../src/useQueries.ts","webpack://_N_E/./node_modules/@trpc/react-query/dist/createHooksInternal-bdff7171.mjs","webpack://_N_E/./node_modules/@trpc/react-query/dist/index.mjs","webpack://_N_E/./node_modules/@trpc/server/dist/codes-c924c3db.mjs","webpack://_N_E/./node_modules/@trpc/server/dist/index-f91d720c.mjs","webpack://_N_E/./node_modules/@trpc/server/dist/transformTRPCResponse-1153b421.mjs","webpack://_N_E/./node_modules/@trpc/server/dist/getCauseFromUnknown-2d66414a.mjs","webpack://_N_E/./node_modules/@trpc/server/dist/shared/index.mjs"],"sourcesContent":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var e=require(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    const changed = this.focused !== focused;\n\n    if (changed) {\n      this.focused = focused;\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(({\n      listener\n    }) => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nexport { FocusManager, focusManager };\n//# sourceMappingURL=focusManager.mjs.map\n","function infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject(\"Missing queryFn for queryKey '\" + context.options.queryHash + \"'\"));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n\n  return;\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n\n  return;\n}\n\nexport { getNextPageParam, getPreviousPageParam, hasNextPage, hasPreviousPage, infiniteQueryBehavior };\n//# sourceMappingURL=infiniteQueryBehavior.mjs.map\n","const defaultLogger = console;\n\nexport { defaultLogger };\n//# sourceMappingURL=logger.mjs.map\n","import { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Removable } from './removable.mjs';\nimport { createRetryer, canFetch } from './retryer.mjs';\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.defaultOptions = config.defaultOptions;\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    var _this$retryer$continu, _this$retryer;\n\n    return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({\n            type: 'failed',\n            failureCount,\n            error\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context)); // Notify cache callback\n\n      await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context)); // Notify cache callback\n\n        await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, undefined, error, this.state.variables, this.state.context, this));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\nexport { Mutation, getDefaultState };\n//# sourceMappingURL=mutation.mjs.map\n","import { scheduleMicrotask } from './utils.mjs';\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nexport { createNotifyManager, notifyManager };\n//# sourceMappingURL=notifyManager.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nconst onlineEvents = ['online', 'offline'];\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        onlineEvents.forEach(event => {\n          window.addEventListener(event, listener, false);\n        });\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          onlineEvents.forEach(event => {\n            window.removeEventListener(event, listener);\n          });\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    const changed = this.online !== online;\n\n    if (changed) {\n      this.online = online;\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(({\n      listener\n    }) => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nexport { OnlineManager, onlineManager };\n//# sourceMappingURL=onlineManager.mjs.map\n","import { isValidTimeout, isServer } from './utils.mjs';\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  }\n\n}\n\nexport { Removable };\n//# sourceMappingURL=removable.mjs.map\n","import { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { sleep } from './utils.mjs';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        const canContinue = isResolved || !shouldPause();\n\n        if (canContinue) {\n          continueResolve(value);\n        }\n\n        return canContinue;\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n\n        return;\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn == null ? void 0 : continueFn();\n      return didContinue ? promise : Promise.resolve();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nexport { CancelledError, canFetch, createRetryer, isCancelledError };\n//# sourceMappingURL=retryer.mjs.map\n","class Subscribable {\n  constructor() {\n    this.listeners = new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    const identity = {\n      listener\n    };\n    this.listeners.add(identity);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(identity);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\nexport { Subscribable };\n//# sourceMappingURL=subscribable.mjs.map\n","// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined' || 'Deno' in window;\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n\n  return;\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nexport { difference, functionalUpdate, getAbortController, hashQueryKey, hashQueryKeyByOptions, isError, isPlainArray, isPlainObject, isQueryKey, isServer, isValidTimeout, matchMutation, matchQuery, noop, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, partialDeepEqual, partialMatchKey, replaceAt, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };\n//# sourceMappingURL=utils.mjs.map\n","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\nimport type { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  if (process.env.NODE_ENV !== 'production' && contextSharing) {\n    client\n      .getLogger()\n      .error(\n        `The contextSharing option has been deprecated and will be removed in the next major version`,\n      )\n  }\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","function identity(x) {\n    return x;\n}\n\n/** @internal */ function pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity;\n    }\n    if (fns.length === 1) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce((prev, fn)=>fn(prev), input);\n    };\n}\n\nfunction isObservable(x) {\n    return typeof x === 'object' && x !== null && 'subscribe' in x;\n}\nfunction observable(subscribe) {\n    const self = {\n        subscribe (observer) {\n            let teardownRef = null;\n            let isDone = false;\n            let unsubscribed = false;\n            let teardownImmediately = false;\n            function unsubscribe() {\n                if (teardownRef === null) {\n                    teardownImmediately = true;\n                    return;\n                }\n                if (unsubscribed) {\n                    return;\n                }\n                unsubscribed = true;\n                if (typeof teardownRef === 'function') {\n                    teardownRef();\n                } else if (teardownRef) {\n                    teardownRef.unsubscribe();\n                }\n            }\n            teardownRef = subscribe({\n                next (value) {\n                    if (isDone) {\n                        return;\n                    }\n                    observer.next?.(value);\n                },\n                error (err) {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.error?.(err);\n                    unsubscribe();\n                },\n                complete () {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.complete?.();\n                    unsubscribe();\n                }\n            });\n            if (teardownImmediately) {\n                unsubscribe();\n            }\n            return {\n                unsubscribe\n            };\n        },\n        pipe (...operations) {\n            return pipeFromArray(operations)(self);\n        }\n    };\n    return self;\n}\n\nexport { isObservable as i, observable as o };\n","export { i as isObservable, o as observable } from '../observable-ade1bad8.mjs';\n\nfunction share(_opts) {\n    return (originalObserver)=>{\n        let refCount = 0;\n        let subscription = null;\n        const observers = [];\n        function startIfNeeded() {\n            if (subscription) {\n                return;\n            }\n            subscription = originalObserver.subscribe({\n                next (value) {\n                    for (const observer of observers){\n                        observer.next?.(value);\n                    }\n                },\n                error (error) {\n                    for (const observer of observers){\n                        observer.error?.(error);\n                    }\n                },\n                complete () {\n                    for (const observer of observers){\n                        observer.complete?.();\n                    }\n                }\n            });\n        }\n        function resetIfNeeded() {\n            // \"resetOnRefCountZero\"\n            if (refCount === 0 && subscription) {\n                const _sub = subscription;\n                subscription = null;\n                _sub.unsubscribe();\n            }\n        }\n        return {\n            subscribe (observer) {\n                refCount++;\n                observers.push(observer);\n                startIfNeeded();\n                return {\n                    unsubscribe () {\n                        refCount--;\n                        resetIfNeeded();\n                        const index = observers.findIndex((v)=>v === observer);\n                        if (index > -1) {\n                            observers.splice(index, 1);\n                        }\n                    }\n                };\n            }\n        };\n    };\n}\n\nfunction map(project) {\n    return (originalObserver)=>{\n        return {\n            subscribe (observer) {\n                let index = 0;\n                const subscription = originalObserver.subscribe({\n                    next (value) {\n                        observer.next?.(project(value, index++));\n                    },\n                    error (error) {\n                        observer.error?.(error);\n                    },\n                    complete () {\n                        observer.complete?.();\n                    }\n                });\n                return subscription;\n            }\n        };\n    };\n}\n\nfunction tap(observer) {\n    return (originalObserver)=>{\n        return {\n            subscribe (observer2) {\n                return originalObserver.subscribe({\n                    next (v) {\n                        observer.next?.(v);\n                        observer2.next?.(v);\n                    },\n                    error (v) {\n                        observer.error?.(v);\n                        observer2.error?.(v);\n                    },\n                    complete () {\n                        observer.complete?.();\n                        observer2.complete?.();\n                    }\n                });\n            }\n        };\n    };\n}\n\nclass ObservableAbortError extends Error {\n    constructor(message){\n        super(message);\n        this.name = 'ObservableAbortError';\n        Object.setPrototypeOf(this, ObservableAbortError.prototype);\n    }\n}\n/** @internal */ function observableToPromise(observable) {\n    let abort;\n    const promise = new Promise((resolve, reject)=>{\n        let isDone = false;\n        function onDone() {\n            if (isDone) {\n                return;\n            }\n            isDone = true;\n            reject(new ObservableAbortError('This operation was aborted.'));\n            obs$.unsubscribe();\n        }\n        const obs$ = observable.subscribe({\n            next (data) {\n                isDone = true;\n                resolve(data);\n                onDone();\n            },\n            error (data) {\n                isDone = true;\n                reject(data);\n                onDone();\n            },\n            complete () {\n                isDone = true;\n                onDone();\n            }\n        });\n        abort = onDone;\n    });\n    return {\n        promise,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        abort: abort\n    };\n}\n\nexport { map, observableToPromise, share, tap };\n","import { observable } from '@trpc/server/observable';\n\n/** @internal */ function createChain(opts) {\n    return observable((observer)=>{\n        function execute(index = 0, op = opts.op) {\n            const next = opts.links[index];\n            if (!next) {\n                throw new Error('No more links to execute - did you forget to add an ending link?');\n            }\n            const subscription = next({\n                op,\n                next (nextOp) {\n                    const nextObserver = execute(index + 1, nextOp);\n                    return nextObserver;\n                }\n            });\n            return subscription;\n        }\n        const obs$ = execute();\n        return obs$.subscribe(observer);\n    });\n}\n\nfunction asArray(value) {\n    return Array.isArray(value) ? value : [\n        value\n    ];\n}\nfunction splitLink(opts) {\n    return (runtime)=>{\n        const yes = asArray(opts.true).map((link)=>link(runtime));\n        const no = asArray(opts.false).map((link)=>link(runtime));\n        return (props)=>{\n            return observable((observer)=>{\n                const links = opts.condition(props.op) ? yes : no;\n                return createChain({\n                    op: props.op,\n                    links\n                }).subscribe(observer);\n            });\n        };\n    };\n}\n\nexport { createChain as c, splitLink as s };\n","function isObject(value) {\n    // check that value is object\n    return !!value && !Array.isArray(value) && typeof value === 'object';\n}\n\n// FIXME:\n// - the generics here are probably unnecessary\n// - the RPC-spec could probably be simplified to combine HTTP + WS\n/** @internal */ function transformResultInner(response, runtime) {\n    if ('error' in response) {\n        const error = runtime.transformer.deserialize(response.error);\n        return {\n            ok: false,\n            error: {\n                ...response,\n                error\n            }\n        };\n    }\n    const result = {\n        ...response.result,\n        ...(!response.result.type || response.result.type === 'data') && {\n            type: 'data',\n            data: runtime.transformer.deserialize(response.result.data)\n        }\n    };\n    return {\n        ok: true,\n        result\n    };\n}\nclass TransformResultError extends Error {\n    constructor(){\n        super('Unable to transform response from server');\n    }\n}\n/**\n * Transforms and validates that the result is a valid TRPCResponse\n * @internal\n */ function transformResult(response, runtime) {\n    let result;\n    try {\n        // Use the data transformers on the JSON-response\n        result = transformResultInner(response, runtime);\n    } catch (err) {\n        throw new TransformResultError();\n    }\n    // check that output of the transformers is a valid TRPCResponse\n    if (!result.ok && (!isObject(result.error.error) || typeof result.error.error.code !== 'number')) {\n        throw new TransformResultError();\n    }\n    if (result.ok && !isObject(result.result)) {\n        throw new TransformResultError();\n    }\n    return result;\n}\n\nexport { isObject as i, transformResult as t };\n","import { getCauseFromUnknown } from '@trpc/server/shared';\nimport { i as isObject } from './transformResult-ace864b8.mjs';\n\nfunction isTRPCClientError(cause) {\n    return cause instanceof TRPCClientError || /**\n     * @deprecated\n     * Delete in next major\n     */ cause instanceof Error && cause.name === 'TRPCClientError';\n}\nfunction isTRPCErrorResponse(obj) {\n    return isObject(obj) && isObject(obj.error) && typeof obj.error.code === 'number' && typeof obj.error.message === 'string';\n}\nclass TRPCClientError extends Error {\n    static from(_cause, opts = {}) {\n        const cause = _cause;\n        if (isTRPCClientError(cause)) {\n            if (opts.meta) {\n                // Decorate with meta error data\n                cause.meta = {\n                    ...cause.meta,\n                    ...opts.meta\n                };\n            }\n            return cause;\n        }\n        if (isTRPCErrorResponse(cause)) {\n            return new TRPCClientError(cause.error.message, {\n                ...opts,\n                result: cause\n            });\n        }\n        if (!(cause instanceof Error)) {\n            return new TRPCClientError('Unknown error', {\n                ...opts,\n                cause: cause\n            });\n        }\n        return new TRPCClientError(cause.message, {\n            ...opts,\n            cause: getCauseFromUnknown(cause)\n        });\n    }\n    constructor(message, opts){\n        const cause = opts?.cause;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        });\n        this.meta = opts?.meta;\n        this.cause = cause;\n        this.shape = opts?.result?.error;\n        this.data = opts?.result?.error.data;\n        this.name = 'TRPCClientError';\n        Object.setPrototypeOf(this, TRPCClientError.prototype);\n    }\n}\n\nexport { TRPCClientError as T };\n","import { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\n\nconst isFunction = (fn)=>typeof fn === 'function';\nfunction getFetch(customFetchImpl) {\n    if (customFetchImpl) {\n        return customFetchImpl;\n    }\n    if (typeof window !== 'undefined' && isFunction(window.fetch)) {\n        return window.fetch;\n    }\n    if (typeof globalThis !== 'undefined' && isFunction(globalThis.fetch)) {\n        return globalThis.fetch;\n    }\n    throw new Error('No fetch implementation found');\n}\n\nfunction getAbortController(customAbortControllerImpl) {\n    if (customAbortControllerImpl) {\n        return customAbortControllerImpl;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof window !== 'undefined' && window.AbortController) {\n        return window.AbortController;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof globalThis !== 'undefined' && globalThis.AbortController) {\n        return globalThis.AbortController;\n    }\n    return null;\n}\n\nfunction resolveHTTPLinkOptions(opts) {\n    return {\n        url: opts.url.toString().replace(/\\/$/, ''),\n        fetch: opts.fetch,\n        AbortController: getAbortController(opts.AbortController)\n    };\n}\n// https://github.com/trpc/trpc/pull/669\nfunction arrayToDict(array) {\n    const dict = {};\n    for(let index = 0; index < array.length; index++){\n        const element = array[index];\n        dict[index] = element;\n    }\n    return dict;\n}\nconst METHOD = {\n    query: 'GET',\n    mutation: 'POST'\n};\nfunction getInput(opts) {\n    return 'input' in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input)=>opts.runtime.transformer.serialize(_input)));\n}\nconst getUrl = (opts)=>{\n    let url = opts.url + '/' + opts.path;\n    const queryParts = [];\n    if ('inputs' in opts) {\n        queryParts.push('batch=1');\n    }\n    if (opts.type === 'query') {\n        const input = getInput(opts);\n        if (input !== undefined) {\n            queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);\n        }\n    }\n    if (queryParts.length) {\n        url += '?' + queryParts.join('&');\n    }\n    return url;\n};\nconst getBody = (opts)=>{\n    if (opts.type === 'query') {\n        return undefined;\n    }\n    const input = getInput(opts);\n    return input !== undefined ? JSON.stringify(input) : undefined;\n};\nconst jsonHttpRequester = (opts)=>{\n    return httpRequest({\n        ...opts,\n        contentTypeHeader: 'application/json',\n        getUrl,\n        getBody\n    });\n};\nasync function fetchHTTPResponse(opts, ac) {\n    const url = opts.getUrl(opts);\n    const body = opts.getBody(opts);\n    const { type  } = opts;\n    const resolvedHeaders = await opts.headers();\n    /* istanbul ignore if -- @preserve */ if (type === 'subscription') {\n        throw new Error('Subscriptions should use wsLink');\n    }\n    const headers = {\n        ...opts.contentTypeHeader ? {\n            'content-type': opts.contentTypeHeader\n        } : {},\n        ...opts.batchModeHeader ? {\n            'trpc-batch-mode': opts.batchModeHeader\n        } : {},\n        ...resolvedHeaders\n    };\n    return getFetch(opts.fetch)(url, {\n        method: METHOD[type],\n        signal: ac?.signal,\n        body: body,\n        headers\n    });\n}\nfunction httpRequest(opts) {\n    const ac = opts.AbortController ? new opts.AbortController() : null;\n    const meta = {};\n    let done = false;\n    const promise = new Promise((resolve, reject)=>{\n        fetchHTTPResponse(opts, ac).then((_res)=>{\n            meta.response = _res;\n            done = true;\n            return _res.json();\n        }).then((json)=>{\n            meta.responseJSON = json;\n            resolve({\n                json: json,\n                meta\n            });\n        }).catch((err)=>{\n            done = true;\n            reject(TRPCClientError.from(err, {\n                meta\n            }));\n        });\n    });\n    const cancel = ()=>{\n        if (!done) {\n            ac?.abort();\n        }\n    };\n    return {\n        promise,\n        cancel\n    };\n}\n\nexport { getBody as a, getFetch as b, fetchHTTPResponse as f, getUrl as g, httpRequest as h, jsonHttpRequester as j, resolveHTTPLinkOptions as r };\n","import { observable } from '@trpc/server/observable';\nimport { t as transformResult } from './transformResult-ace864b8.mjs';\nimport { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\nimport { r as resolveHTTPLinkOptions, g as getUrl, j as jsonHttpRequester } from './httpUtils-b9d0cb48.mjs';\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */ /**\n * A function that should never be called unless we messed something up.\n */ const throwFatalError = ()=>{\n    throw new Error('Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new');\n};\n/**\n * Dataloader that's very inspired by https://github.com/graphql/dataloader\n * Less configuration, no caching, and allows you to cancel requests\n * When cancelling a single fetch the whole batch will be cancelled only when _all_ items are cancelled\n */ function dataLoader(batchLoader) {\n    let pendingItems = null;\n    let dispatchTimer = null;\n    const destroyTimerAndPendingItems = ()=>{\n        clearTimeout(dispatchTimer);\n        dispatchTimer = null;\n        pendingItems = null;\n    };\n    /**\n   * Iterate through the items and split them into groups based on the `batchLoader`'s validate function\n   */ function groupItems(items) {\n        const groupedItems = [\n            []\n        ];\n        let index = 0;\n        while(true){\n            const item = items[index];\n            if (!item) {\n                break;\n            }\n            const lastGroup = groupedItems[groupedItems.length - 1];\n            if (item.aborted) {\n                // Item was aborted before it was dispatched\n                item.reject?.(new Error('Aborted'));\n                index++;\n                continue;\n            }\n            const isValid = batchLoader.validate(lastGroup.concat(item).map((it)=>it.key));\n            if (isValid) {\n                lastGroup.push(item);\n                index++;\n                continue;\n            }\n            if (lastGroup.length === 0) {\n                item.reject?.(new Error('Input is too big for a single dispatch'));\n                index++;\n                continue;\n            }\n            // Create new group, next iteration will try to add the item to that\n            groupedItems.push([]);\n        }\n        return groupedItems;\n    }\n    function dispatch() {\n        const groupedItems = groupItems(pendingItems);\n        destroyTimerAndPendingItems();\n        // Create batches for each group of items\n        for (const items of groupedItems){\n            if (!items.length) {\n                continue;\n            }\n            const batch = {\n                items,\n                cancel: throwFatalError\n            };\n            for (const item of items){\n                item.batch = batch;\n            }\n            const unitResolver = (index, value)=>{\n                const item = batch.items[index];\n                item.resolve?.(value);\n                item.batch = null;\n                item.reject = null;\n                item.resolve = null;\n            };\n            const { promise , cancel  } = batchLoader.fetch(batch.items.map((_item)=>_item.key), unitResolver);\n            batch.cancel = cancel;\n            promise.then((result)=>{\n                for(let i = 0; i < result.length; i++){\n                    const value = result[i];\n                    unitResolver(i, value);\n                }\n                for (const item of batch.items){\n                    item.reject?.(new Error('Missing result'));\n                    item.batch = null;\n                }\n            }).catch((cause)=>{\n                for (const item of batch.items){\n                    item.reject?.(cause);\n                    item.batch = null;\n                }\n            });\n        }\n    }\n    function load(key) {\n        const item = {\n            aborted: false,\n            key,\n            batch: null,\n            resolve: throwFatalError,\n            reject: throwFatalError\n        };\n        const promise = new Promise((resolve, reject)=>{\n            item.reject = reject;\n            item.resolve = resolve;\n            if (!pendingItems) {\n                pendingItems = [];\n            }\n            pendingItems.push(item);\n        });\n        if (!dispatchTimer) {\n            dispatchTimer = setTimeout(dispatch);\n        }\n        const cancel = ()=>{\n            item.aborted = true;\n            if (item.batch?.items.every((item)=>item.aborted)) {\n                // All items in the batch have been cancelled\n                item.batch.cancel();\n                item.batch = null;\n            }\n        };\n        return {\n            promise,\n            cancel\n        };\n    }\n    return {\n        load\n    };\n}\n\n/**\n * @internal\n */ function createHTTPBatchLink(requester) {\n    return function httpBatchLink(opts) {\n        const resolvedOpts = resolveHTTPLinkOptions(opts);\n        const maxURLLength = opts.maxURLLength ?? Infinity;\n        // initialized config\n        return (runtime)=>{\n            const batchLoader = (type)=>{\n                const validate = (batchOps)=>{\n                    if (maxURLLength === Infinity) {\n                        // escape hatch for quick calcs\n                        return true;\n                    }\n                    const path = batchOps.map((op)=>op.path).join(',');\n                    const inputs = batchOps.map((op)=>op.input);\n                    const url = getUrl({\n                        ...resolvedOpts,\n                        runtime,\n                        type,\n                        path,\n                        inputs\n                    });\n                    return url.length <= maxURLLength;\n                };\n                const fetch = requester({\n                    ...resolvedOpts,\n                    runtime,\n                    type,\n                    opts\n                });\n                return {\n                    validate,\n                    fetch\n                };\n            };\n            const query = dataLoader(batchLoader('query'));\n            const mutation = dataLoader(batchLoader('mutation'));\n            const subscription = dataLoader(batchLoader('subscription'));\n            const loaders = {\n                query,\n                subscription,\n                mutation\n            };\n            return ({ op  })=>{\n                return observable((observer)=>{\n                    const loader = loaders[op.type];\n                    const { promise , cancel  } = loader.load(op);\n                    let _res = undefined;\n                    promise.then((res)=>{\n                        _res = res;\n                        const transformed = transformResult(res.json, runtime);\n                        if (!transformed.ok) {\n                            observer.error(TRPCClientError.from(transformed.error, {\n                                meta: res.meta\n                            }));\n                            return;\n                        }\n                        observer.next({\n                            context: res.meta,\n                            result: transformed.result\n                        });\n                        observer.complete();\n                    }).catch((err)=>{\n                        observer.error(TRPCClientError.from(err, {\n                            meta: _res?.meta\n                        }));\n                    });\n                    return ()=>{\n                        cancel();\n                    };\n                });\n            };\n        };\n    };\n}\n\nconst batchRequester = (requesterOpts)=>{\n    return (batchOps)=>{\n        const path = batchOps.map((op)=>op.path).join(',');\n        const inputs = batchOps.map((op)=>op.input);\n        const { promise , cancel  } = jsonHttpRequester({\n            ...requesterOpts,\n            path,\n            inputs,\n            headers () {\n                if (!requesterOpts.opts.headers) {\n                    return {};\n                }\n                if (typeof requesterOpts.opts.headers === 'function') {\n                    return requesterOpts.opts.headers({\n                        opList: batchOps\n                    });\n                }\n                return requesterOpts.opts.headers;\n            }\n        });\n        return {\n            promise: promise.then((res)=>{\n                const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(()=>res.json);\n                const result = resJSON.map((item)=>({\n                        meta: res.meta,\n                        json: item\n                    }));\n                return result;\n            }),\n            cancel\n        };\n    };\n};\nconst httpBatchLink = createHTTPBatchLink(batchRequester);\n\nexport { createHTTPBatchLink as c, httpBatchLink as h };\n","import { observable } from '@trpc/server/observable';\nimport { t as transformResult } from '../transformResult-ace864b8.mjs';\nimport { T as TRPCClientError } from '../TRPCClientError-38f9a32a.mjs';\nimport { r as resolveHTTPLinkOptions, j as jsonHttpRequester } from '../httpUtils-b9d0cb48.mjs';\nimport '@trpc/server/shared';\n\nfunction httpLinkFactory(factoryOpts) {\n    return (opts)=>{\n        const resolvedOpts = resolveHTTPLinkOptions(opts);\n        return (runtime)=>({ op  })=>observable((observer)=>{\n                    const { path , input , type  } = op;\n                    const { promise , cancel  } = factoryOpts.requester({\n                        ...resolvedOpts,\n                        runtime,\n                        type,\n                        path,\n                        input,\n                        headers () {\n                            if (!opts.headers) {\n                                return {};\n                            }\n                            if (typeof opts.headers === 'function') {\n                                return opts.headers({\n                                    op\n                                });\n                            }\n                            return opts.headers;\n                        }\n                    });\n                    let meta = undefined;\n                    promise.then((res)=>{\n                        meta = res.meta;\n                        const transformed = transformResult(res.json, runtime);\n                        if (!transformed.ok) {\n                            observer.error(TRPCClientError.from(transformed.error, {\n                                meta\n                            }));\n                            return;\n                        }\n                        observer.next({\n                            context: res.meta,\n                            result: transformed.result\n                        });\n                        observer.complete();\n                    }).catch((cause)=>{\n                        observer.error(TRPCClientError.from(cause, {\n                            meta\n                        }));\n                    });\n                    return ()=>{\n                        cancel();\n                    };\n                });\n    };\n}\n/**\n * @see https://trpc.io/docs/client/links/httpLink\n */ const httpLink = httpLinkFactory({\n    requester: jsonHttpRequester\n});\n\nexport { httpLink, httpLinkFactory };\n","import { observable, tap } from '@trpc/server/observable';\n\n/// <reference lib=\"dom.iterable\" />\nfunction isFormData(value) {\n    if (typeof FormData === 'undefined') {\n        // FormData is not supported\n        return false;\n    }\n    return value instanceof FormData;\n}\nconst palettes = {\n    css: {\n        query: [\n            '72e3ff',\n            '3fb0d8'\n        ],\n        mutation: [\n            'c5a3fc',\n            '904dfc'\n        ],\n        subscription: [\n            'ff49e1',\n            'd83fbe'\n        ]\n    },\n    ansi: {\n        regular: {\n            // Cyan background, black and white text respectively\n            query: [\n                '\\x1b[30;46m',\n                '\\x1b[97;46m'\n            ],\n            // Magenta background, black and white text respectively\n            mutation: [\n                '\\x1b[30;45m',\n                '\\x1b[97;45m'\n            ],\n            // Green background, black and white text respectively\n            subscription: [\n                '\\x1b[30;42m',\n                '\\x1b[97;42m'\n            ]\n        },\n        bold: {\n            query: [\n                '\\x1b[1;30;46m',\n                '\\x1b[1;97;46m'\n            ],\n            mutation: [\n                '\\x1b[1;30;45m',\n                '\\x1b[1;97;45m'\n            ],\n            subscription: [\n                '\\x1b[1;30;42m',\n                '\\x1b[1;97;42m'\n            ]\n        }\n    }\n};\nfunction constructPartsAndArgs(opts) {\n    const { direction , type , path , id , input  } = opts;\n    const parts = [];\n    const args = [];\n    if (opts.colorMode === 'ansi') {\n        const [lightRegular, darkRegular] = palettes.ansi.regular[type];\n        const [lightBold, darkBold] = palettes.ansi.bold[type];\n        const reset = '\\x1b[0m';\n        parts.push(direction === 'up' ? lightRegular : darkRegular, direction === 'up' ? '>>' : '<<', type, direction === 'up' ? lightBold : darkBold, `#${id}`, path, reset);\n        if (direction === 'up') {\n            args.push({\n                input: opts.input\n            });\n        } else {\n            args.push({\n                input: opts.input,\n                // strip context from result cause it's too noisy in terminal wihtout collapse mode\n                result: 'result' in opts.result ? opts.result.result : opts.result,\n                elapsedMs: opts.elapsedMs\n            });\n        }\n        return {\n            parts,\n            args\n        };\n    }\n    const [light, dark] = palettes.css[type];\n    const css = `\n    background-color: #${direction === 'up' ? light : dark}; \n    color: ${direction === 'up' ? 'black' : 'white'};\n    padding: 2px;\n  `;\n    parts.push('%c', direction === 'up' ? '>>' : '<<', type, `#${id}`, `%c${path}%c`, '%O');\n    args.push(css, `${css}; font-weight: bold;`, `${css}; font-weight: normal;`);\n    if (direction === 'up') {\n        args.push({\n            input,\n            context: opts.context\n        });\n    } else {\n        args.push({\n            input,\n            result: opts.result,\n            elapsedMs: opts.elapsedMs,\n            context: opts.context\n        });\n    }\n    return {\n        parts,\n        args\n    };\n}\n// maybe this should be moved to it's own package\nconst defaultLogger = ({ c =console , colorMode ='css'  })=>(props)=>{\n        const rawInput = props.input;\n        const input = isFormData(rawInput) ? Object.fromEntries(rawInput) : rawInput;\n        const { parts , args  } = constructPartsAndArgs({\n            ...props,\n            colorMode,\n            input\n        });\n        const fn = props.direction === 'down' && props.result && (props.result instanceof Error || 'error' in props.result.result) ? 'error' : 'log';\n        c[fn].apply(null, [\n            parts.join(' ')\n        ].concat(args));\n    };\n/**\n * @see https://trpc.io/docs/client/links/loggerLink\n */ function loggerLink(opts = {}) {\n    const { enabled =()=>true  } = opts;\n    const colorMode = opts.colorMode ?? (typeof window === 'undefined' ? 'ansi' : 'css');\n    const { logger =defaultLogger({\n        c: opts.console,\n        colorMode\n    })  } = opts;\n    return ()=>{\n        return ({ op , next  })=>{\n            return observable((observer)=>{\n                // ->\n                enabled({\n                    ...op,\n                    direction: 'up'\n                }) && logger({\n                    ...op,\n                    direction: 'up'\n                });\n                const requestStartTime = Date.now();\n                function logResult(result) {\n                    const elapsedMs = Date.now() - requestStartTime;\n                    enabled({\n                        ...op,\n                        direction: 'down',\n                        result\n                    }) && logger({\n                        ...op,\n                        direction: 'down',\n                        elapsedMs,\n                        result\n                    });\n                }\n                return next(op).pipe(tap({\n                    next (result) {\n                        logResult(result);\n                    },\n                    error (result) {\n                        logResult(result);\n                    }\n                })).subscribe(observer);\n            });\n        };\n    };\n}\n\nexport { loggerLink };\n","import { observable } from '@trpc/server/observable';\nimport { t as transformResult } from '../transformResult-ace864b8.mjs';\nimport { T as TRPCClientError } from '../TRPCClientError-38f9a32a.mjs';\nimport '@trpc/server/shared';\n\n/* istanbul ignore next -- @preserve */ const retryDelay = (attemptIndex)=>attemptIndex === 0 ? 0 : Math.min(1000 * 2 ** attemptIndex, 30000);\n\nfunction createWSClient(opts) {\n    const { url , WebSocket: WebSocketImpl = WebSocket , retryDelayMs: retryDelayFn = retryDelay , onOpen , onClose ,  } = opts;\n    /* istanbul ignore next -- @preserve */ if (!WebSocketImpl) {\n        throw new Error(\"No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill\");\n    }\n    /**\n   * outgoing messages buffer whilst not open\n   */ let outgoing = [];\n    const pendingRequests = Object.create(null);\n    let connectAttempt = 0;\n    let dispatchTimer = null;\n    let connectTimer = null;\n    let activeConnection = createWS();\n    let state = 'connecting';\n    /**\n   * tries to send the list of messages\n   */ function dispatch() {\n        if (state !== 'open' || dispatchTimer) {\n            return;\n        }\n        dispatchTimer = setTimeout(()=>{\n            dispatchTimer = null;\n            if (outgoing.length === 1) {\n                // single send\n                activeConnection.send(JSON.stringify(outgoing.pop()));\n            } else {\n                // batch send\n                activeConnection.send(JSON.stringify(outgoing));\n            }\n            // clear\n            outgoing = [];\n        });\n    }\n    function tryReconnect() {\n        if (connectTimer !== null || state === 'closed') {\n            return;\n        }\n        const timeout = retryDelayFn(connectAttempt++);\n        reconnectInMs(timeout);\n    }\n    function reconnect() {\n        state = 'connecting';\n        const oldConnection = activeConnection;\n        activeConnection = createWS();\n        closeIfNoPending(oldConnection);\n    }\n    function reconnectInMs(ms) {\n        if (connectTimer) {\n            return;\n        }\n        state = 'connecting';\n        connectTimer = setTimeout(reconnect, ms);\n    }\n    function closeIfNoPending(conn) {\n        // disconnect as soon as there are are no pending result\n        const hasPendingRequests = Object.values(pendingRequests).some((p)=>p.ws === conn);\n        if (!hasPendingRequests) {\n            conn.close();\n        }\n    }\n    function closeActiveSubscriptions() {\n        Object.values(pendingRequests).forEach((req)=>{\n            if (req.type === 'subscription') {\n                req.callbacks.complete();\n            }\n        });\n    }\n    function resumeSubscriptionOnReconnect(req) {\n        if (outgoing.some((r)=>r.id === req.op.id)) {\n            return;\n        }\n        request(req.op, req.callbacks);\n    }\n    function createWS() {\n        const urlString = typeof url === 'function' ? url() : url;\n        const conn = new WebSocketImpl(urlString);\n        clearTimeout(connectTimer);\n        connectTimer = null;\n        conn.addEventListener('open', ()=>{\n            /* istanbul ignore next -- @preserve */ if (conn !== activeConnection) {\n                return;\n            }\n            connectAttempt = 0;\n            state = 'open';\n            onOpen?.();\n            dispatch();\n        });\n        conn.addEventListener('error', ()=>{\n            if (conn === activeConnection) {\n                tryReconnect();\n            }\n        });\n        const handleIncomingRequest = (req)=>{\n            if (req.method === 'reconnect' && conn === activeConnection) {\n                if (state === 'open') {\n                    onClose?.();\n                }\n                reconnect();\n                // notify subscribers\n                for (const pendingReq of Object.values(pendingRequests)){\n                    if (pendingReq.type === 'subscription') {\n                        resumeSubscriptionOnReconnect(pendingReq);\n                    }\n                }\n            }\n        };\n        const handleIncomingResponse = (data)=>{\n            const req = data.id !== null && pendingRequests[data.id];\n            if (!req) {\n                // do something?\n                return;\n            }\n            req.callbacks.next?.(data);\n            if (req.ws !== activeConnection && conn === activeConnection) {\n                const oldWs = req.ws;\n                // gracefully replace old connection with this\n                req.ws = activeConnection;\n                closeIfNoPending(oldWs);\n            }\n            if ('result' in data && data.result.type === 'stopped' && conn === activeConnection) {\n                req.callbacks.complete();\n            }\n        };\n        conn.addEventListener('message', ({ data  })=>{\n            const msg = JSON.parse(data);\n            if ('method' in msg) {\n                handleIncomingRequest(msg);\n            } else {\n                handleIncomingResponse(msg);\n            }\n            if (conn !== activeConnection || state === 'closed') {\n                // when receiving a message, we close old connection that has no pending requests\n                closeIfNoPending(conn);\n            }\n        });\n        conn.addEventListener('close', ({ code  })=>{\n            if (state === 'open') {\n                onClose?.({\n                    code\n                });\n            }\n            if (activeConnection === conn) {\n                // connection might have been replaced already\n                tryReconnect();\n            }\n            for (const [key, req] of Object.entries(pendingRequests)){\n                if (req.ws !== conn) {\n                    continue;\n                }\n                if (state === 'closed') {\n                    // If the connection was closed, we just call `complete()` on the request\n                    delete pendingRequests[key];\n                    req.callbacks.complete?.();\n                    continue;\n                }\n                // The connection was closed either unexpectedly or because of a reconnect\n                if (req.type === 'subscription') {\n                    // Subscriptions will resume after we've reconnected\n                    resumeSubscriptionOnReconnect(req);\n                } else {\n                    // Queries and mutations will error if interrupted\n                    delete pendingRequests[key];\n                    req.callbacks.error?.(TRPCClientError.from(new TRPCWebSocketClosedError('WebSocket closed prematurely')));\n                }\n            }\n        });\n        return conn;\n    }\n    function request(op, callbacks) {\n        const { type , input , path , id  } = op;\n        const envelope = {\n            id,\n            method: type,\n            params: {\n                input,\n                path\n            }\n        };\n        pendingRequests[id] = {\n            ws: activeConnection,\n            type,\n            callbacks,\n            op\n        };\n        // enqueue message\n        outgoing.push(envelope);\n        dispatch();\n        return ()=>{\n            const callbacks = pendingRequests[id]?.callbacks;\n            delete pendingRequests[id];\n            outgoing = outgoing.filter((msg)=>msg.id !== id);\n            callbacks?.complete?.();\n            if (activeConnection.readyState === WebSocketImpl.OPEN && op.type === 'subscription') {\n                outgoing.push({\n                    id,\n                    method: 'subscription.stop'\n                });\n                dispatch();\n            }\n        };\n    }\n    return {\n        close: ()=>{\n            state = 'closed';\n            onClose?.();\n            closeActiveSubscriptions();\n            closeIfNoPending(activeConnection);\n            clearTimeout(connectTimer);\n            connectTimer = null;\n        },\n        request,\n        getConnection () {\n            return activeConnection;\n        }\n    };\n}\nclass TRPCWebSocketClosedError extends Error {\n    constructor(message){\n        super(message);\n        this.name = 'TRPCWebSocketClosedError';\n        Object.setPrototypeOf(this, TRPCWebSocketClosedError.prototype);\n    }\n}\n/**\n * @see https://trpc.io/docs/client/links/wsLink\n */ function wsLink(opts) {\n    return (runtime)=>{\n        const { client  } = opts;\n        return ({ op  })=>{\n            return observable((observer)=>{\n                const { type , path , id , context  } = op;\n                const input = runtime.transformer.serialize(op.input);\n                const unsub = client.request({\n                    type,\n                    path,\n                    input,\n                    id,\n                    context\n                }, {\n                    error (err) {\n                        observer.error(err);\n                        unsub();\n                    },\n                    complete () {\n                        observer.complete();\n                    },\n                    next (message) {\n                        const transformed = transformResult(message, runtime);\n                        if (!transformed.ok) {\n                            observer.error(TRPCClientError.from(transformed.error));\n                            return;\n                        }\n                        observer.next({\n                            result: transformed.result\n                        });\n                        if (op.type !== 'subscription') {\n                            // if it isn't a subscription we don't care about next response\n                            unsub();\n                            observer.complete();\n                        }\n                    }\n                });\n                return ()=>{\n                    unsub();\n                };\n            });\n        };\n    };\n}\n\nexport { createWSClient, wsLink };\n","import { share, observableToPromise } from '@trpc/server/observable';\nimport { c as createChain } from './splitLink-4c75f7be.mjs';\nexport { s as splitLink } from './splitLink-4c75f7be.mjs';\nimport { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\nexport { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\nimport { createFlatProxy, createRecursiveProxy } from '@trpc/server/shared';\nimport { f as fetchHTTPResponse, g as getUrl, a as getBody$1, h as httpRequest } from './httpUtils-b9d0cb48.mjs';\nexport { b as getFetch } from './httpUtils-b9d0cb48.mjs';\nimport { c as createHTTPBatchLink } from './httpBatchLink-d0f9eac9.mjs';\nexport { h as httpBatchLink } from './httpBatchLink-d0f9eac9.mjs';\nimport { httpLinkFactory } from './links/httpLink.mjs';\nexport { httpLink, httpLinkFactory } from './links/httpLink.mjs';\nexport { loggerLink } from './links/loggerLink.mjs';\nexport { createWSClient, wsLink } from './links/wsLink.mjs';\nimport './transformResult-ace864b8.mjs';\n\nclass TRPCUntypedClient {\n    $request({ type , input , path , context ={}  }) {\n        const chain$ = createChain({\n            links: this.links,\n            op: {\n                id: ++this.requestId,\n                type,\n                path,\n                input,\n                context\n            }\n        });\n        return chain$.pipe(share());\n    }\n    requestAsPromise(opts) {\n        const req$ = this.$request(opts);\n        const { promise , abort  } = observableToPromise(req$);\n        const abortablePromise = new Promise((resolve, reject)=>{\n            opts.signal?.addEventListener('abort', abort);\n            promise.then((envelope)=>{\n                resolve(envelope.result.data);\n            }).catch((err)=>{\n                reject(TRPCClientError.from(err));\n            });\n        });\n        return abortablePromise;\n    }\n    query(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'query',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    mutation(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'mutation',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    subscription(path, input, opts) {\n        const observable$ = this.$request({\n            type: 'subscription',\n            path,\n            input,\n            context: opts?.context\n        });\n        return observable$.subscribe({\n            next (envelope) {\n                if (envelope.result.type === 'started') {\n                    opts.onStarted?.();\n                } else if (envelope.result.type === 'stopped') {\n                    opts.onStopped?.();\n                } else {\n                    opts.onData?.(envelope.result.data);\n                }\n            },\n            error (err) {\n                opts.onError?.(err);\n            },\n            complete () {\n                opts.onComplete?.();\n            }\n        });\n    }\n    constructor(opts){\n        this.requestId = 0;\n        const combinedTransformer = (()=>{\n            const transformer = opts.transformer;\n            if (!transformer) {\n                return {\n                    input: {\n                        serialize: (data)=>data,\n                        deserialize: (data)=>data\n                    },\n                    output: {\n                        serialize: (data)=>data,\n                        deserialize: (data)=>data\n                    }\n                };\n            }\n            if ('input' in transformer) {\n                return opts.transformer;\n            }\n            return {\n                input: transformer,\n                output: transformer\n            };\n        })();\n        this.runtime = {\n            transformer: {\n                serialize: (data)=>combinedTransformer.input.serialize(data),\n                deserialize: (data)=>combinedTransformer.output.deserialize(data)\n            },\n            combinedTransformer\n        };\n        // Initialize the links\n        this.links = opts.links.map((link)=>link(this.runtime));\n    }\n}\n\nfunction createTRPCUntypedClient(opts) {\n    return new TRPCUntypedClient(opts);\n}\n\n/**\n * @deprecated use `createTRPCProxyClient` instead\n */ function createTRPCClient(opts) {\n    const client = new TRPCUntypedClient(opts);\n    return client;\n}\n\nconst clientCallTypeMap = {\n    query: 'query',\n    mutate: 'mutation',\n    subscribe: 'subscription'\n};\n/** @internal */ const clientCallTypeToProcedureType = (clientCallType)=>{\n    return clientCallTypeMap[clientCallType];\n};\n/**\n * @deprecated use `createTRPCProxyClient` instead\n * @internal\n */ function createTRPCClientProxy(client) {\n    return createFlatProxy((key)=>{\n        if (client.hasOwnProperty(key)) {\n            return client[key];\n        }\n        if (key === '__untypedClient') {\n            return client;\n        }\n        return createRecursiveProxy(({ path , args  })=>{\n            const pathCopy = [\n                key,\n                ...path\n            ];\n            const procedureType = clientCallTypeToProcedureType(pathCopy.pop());\n            const fullPath = pathCopy.join('.');\n            return client[procedureType](fullPath, ...args);\n        });\n    });\n}\nfunction createTRPCProxyClient(opts) {\n    const client = new TRPCUntypedClient(opts);\n    const proxy = createTRPCClientProxy(client);\n    return proxy;\n}\n/**\n * Get an untyped client from a proxy client\n * @internal\n */ function getUntypedClient(client) {\n    return client.__untypedClient;\n}\n\nfunction getTextDecoder(customTextDecoder) {\n    if (customTextDecoder) {\n        return customTextDecoder;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof window !== 'undefined' && window.TextDecoder) {\n        return new window.TextDecoder();\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof globalThis !== 'undefined' && globalThis.TextDecoder) {\n        return new globalThis.TextDecoder();\n    }\n    throw new Error('No TextDecoder implementation found');\n}\n\n// Stream parsing adapted from https://www.loginradius.com/blog/engineering/guest-post/http-streaming-with-nodejs-and-fetch-api/\n/**\n * @internal\n * @description Take a stream of bytes and call `onLine` with\n * a JSON object for each line in the stream. Expected stream\n * format is:\n * ```json\n * {\"1\": {...}\n * ,\"0\": {...}\n * }\n * ```\n */ async function parseJSONStream(opts) {\n    const parse = opts.parse ?? JSON.parse;\n    const onLine = (line)=>{\n        if (opts.signal?.aborted) return;\n        if (!line || line === '}') {\n            return;\n        }\n        /**\n     * At this point, `line` can be one of two things:\n     * - The first line of the stream `{\"2\":{...}`\n     * - A line in the middle of the stream `,\"2\":{...}`\n     */ const indexOfColon = line.indexOf(':');\n        const indexAsStr = line.substring(2, indexOfColon - 1);\n        const text = line.substring(indexOfColon + 1);\n        opts.onSingle(Number(indexAsStr), parse(text));\n    };\n    await readLines(opts.readableStream, onLine, opts.textDecoder);\n}\n/**\n * Handle transforming a stream of bytes into lines of text.\n * To avoid using AsyncIterators / AsyncGenerators,\n * we use a callback for each line.\n *\n * @param readableStream can be a NodeJS stream or a WebAPI stream\n * @param onLine will be called for every line ('\\n' delimited) in the stream\n */ async function readLines(readableStream, onLine, textDecoder) {\n    let partOfLine = '';\n    const onChunk = (chunk)=>{\n        const chunkText = textDecoder.decode(chunk);\n        const chunkLines = chunkText.split('\\n');\n        if (chunkLines.length === 1) {\n            partOfLine += chunkLines[0];\n        } else if (chunkLines.length > 1) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked on line above\n            onLine(partOfLine + chunkLines[0]);\n            for(let i = 1; i < chunkLines.length - 1; i++){\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked on line above\n                onLine(chunkLines[i]);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length doesn't change, so is necessarily > 1\n            partOfLine = chunkLines[chunkLines.length - 1];\n        }\n    };\n    // we handle 2 different types of streams, this if where we figure out which one we have\n    if ('getReader' in readableStream) {\n        await readStandardChunks(readableStream, onChunk);\n    } else {\n        await readNodeChunks(readableStream, onChunk);\n    }\n    onLine(partOfLine);\n}\n/**\n * Handle NodeJS stream\n */ function readNodeChunks(stream, onChunk) {\n    return new Promise((resolve)=>{\n        stream.on('data', onChunk);\n        stream.on('end', resolve);\n    });\n}\n/**\n * Handle WebAPI stream\n */ async function readStandardChunks(stream, onChunk) {\n    const reader = stream.getReader();\n    let readResult = await reader.read();\n    while(!readResult.done){\n        onChunk(readResult.value);\n        readResult = await reader.read();\n    }\n}\nconst streamingJsonHttpRequester = (opts, onSingle)=>{\n    const ac = opts.AbortController ? new opts.AbortController() : null;\n    const responsePromise = fetchHTTPResponse({\n        ...opts,\n        contentTypeHeader: 'application/json',\n        batchModeHeader: 'stream',\n        getUrl,\n        getBody: getBody$1\n    }, ac);\n    const cancel = ()=>ac?.abort();\n    const promise = responsePromise.then(async (res)=>{\n        if (!res.body) throw new Error('Received response without body');\n        const meta = {\n            response: res\n        };\n        return parseJSONStream({\n            readableStream: res.body,\n            onSingle,\n            parse: (string)=>({\n                    json: JSON.parse(string),\n                    meta\n                }),\n            signal: ac?.signal,\n            textDecoder: opts.textDecoder\n        });\n    });\n    return {\n        cancel,\n        promise\n    };\n};\n\nconst streamRequester = (requesterOpts)=>{\n    const textDecoder = getTextDecoder(requesterOpts.opts.textDecoder);\n    return (batchOps, unitResolver)=>{\n        const path = batchOps.map((op)=>op.path).join(',');\n        const inputs = batchOps.map((op)=>op.input);\n        const { cancel , promise  } = streamingJsonHttpRequester({\n            ...requesterOpts,\n            textDecoder,\n            path,\n            inputs,\n            headers () {\n                if (!requesterOpts.opts.headers) {\n                    return {};\n                }\n                if (typeof requesterOpts.opts.headers === 'function') {\n                    return requesterOpts.opts.headers({\n                        opList: batchOps\n                    });\n                }\n                return requesterOpts.opts.headers;\n            }\n        }, (index, res)=>{\n            unitResolver(index, res);\n        });\n        return {\n            /**\n       * return an empty array because the batchLoader expects an array of results\n       * but we've already called the `unitResolver` for each of them, there's\n       * nothing left to do here.\n       */ promise: promise.then(()=>[]),\n            cancel\n        };\n    };\n};\nconst unstable_httpBatchStreamLink = createHTTPBatchLink(streamRequester);\n\nconst getBody = (opts)=>{\n    if (!('input' in opts)) {\n        return undefined;\n    }\n    if (!(opts.input instanceof FormData)) {\n        throw new Error('Input is not FormData');\n    }\n    return opts.input;\n};\nconst formDataRequester = (opts)=>{\n    if (opts.type !== 'mutation') {\n        // TODO(?) handle formdata queries\n        throw new Error('We only handle mutations with formdata');\n    }\n    return httpRequest({\n        ...opts,\n        getUrl () {\n            return `${opts.url}/${opts.path}`;\n        },\n        getBody\n    });\n};\nconst experimental_formDataLink = httpLinkFactory({\n    requester: formDataRequester\n});\n\nexport { TRPCUntypedClient, clientCallTypeToProcedureType, createTRPCClient, createTRPCClientProxy, createTRPCProxyClient, createTRPCUntypedClient, experimental_formDataLink, getUntypedClient, unstable_httpBatchStreamLink };\n","/**\n * To allow easy interactions with groups of related queries, such as\n * invalidating all queries of a router, we use an array as the path when\n * storing in tanstack query. This function converts from the `.` separated\n * path passed around internally by both the legacy and proxy implementation.\n * https://github.com/trpc/trpc/issues/2611\n **/ function getArrayQueryKey(queryKey, type) {\n    const queryKeyArrayed = Array.isArray(queryKey) ? queryKey : [\n        queryKey\n    ];\n    const [path, input] = queryKeyArrayed;\n    const arrayPath = typeof path !== 'string' || path === '' ? [] : path.split('.');\n    // Construct a query key that is easy to destructure and flexible for\n    // partial selecting etc.\n    // https://github.com/trpc/trpc/issues/3128\n    if (!input && (!type || type === 'any')) // for `utils.invalidate()` to match all queries (including vanilla react-query)\n    // we don't want nested array if path is empty, i.e. `[]` instead of `[[]]`\n    return arrayPath.length ? [\n        arrayPath\n    ] : [];\n    return [\n        arrayPath,\n        {\n            ...typeof input !== 'undefined' && {\n                input: input\n            },\n            ...type && type !== 'any' && {\n                type: type\n            }\n        }\n    ];\n}\n\nexport { getArrayQueryKey as g };\n","import { shallowEqualObjects, noop, isServer, isValidTimeout, timeUntilStale, replaceData } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { canFetch, isCancelledError } from './retryer.mjs';\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = new Set();\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (process.env.NODE_ENV !== 'production' && typeof (options == null ? void 0 : options.isDataEqual) !== 'undefined') {\n      this.client.getLogger().error(\"The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option\");\n    }\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this\n      });\n    }\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    const result = this.createResult(query, options);\n\n    if (shouldAssignObserverCurrentProperties(this, result, options)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult everytime\n      // an observer reads an optimistic value.\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.currentResult = result;\n      this.currentResultOptions = this.options;\n      this.currentResultState = this.currentQuery.state;\n    }\n\n    return result;\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const isLoading = status === 'loading';\n    const isError = status === 'error';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === 'function' ? notifyOnChangeProps() : notifyOnChangeProps;\n\n      if (notifyOnChangePropsValue === 'all' || !notifyOnChangePropsValue && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n} // this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\n\n\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {\n  // it is important to keep this condition like this for three reasons:\n  // 1. It will get removed in the v5\n  // 2. it reads: don't update the properties if we want to keep the previous\n  // data.\n  // 3. The opposite condition (!options.keepPreviousData) would fallthrough\n  // and will result in a bad decision\n  if (options.keepPreviousData) {\n    return false;\n  } // this means we want to put some placeholder data when pending and queryKey\n  // changed.\n\n\n  if (options.placeholderData !== undefined) {\n    // re-assign properties only if current data is placeholder data\n    // which means that data did not arrive yet, so, if there is some cached data\n    // we need to \"prepare\" to receive it\n    return optimisticResult.isPlaceholderData;\n  } // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n\n\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  } // basically, just keep previous properties if nothing changed\n\n\n  return false;\n}\n\nexport { QueryObserver };\n//# sourceMappingURL=queryObserver.mjs.map\n","'use client'\n// Temporary workaround due to an issue with react-native uSES - https://github.com/TanStack/query/pull/3601\nimport { useSyncExternalStore as uSES } from 'use-sync-external-store/shim/index.js'\n\nexport const useSyncExternalStore = uSES\n","'use client'\nimport * as React from 'react'\n\n// CONTEXT\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","function shouldThrowError(_useErrorBoundary, params) {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params);\n  }\n\n  return !!_useErrorBoundary;\n}\n\nexport { shouldThrowError };\n//# sourceMappingURL=utils.mjs.map\n","'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  UseErrorBoundary,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  useErrorBoundary: UseErrorBoundary<\n    TQueryFnData,\n    TError,\n    TQueryData,\n    TQueryKey\n  >\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(useErrorBoundary, [result.error, query])\n  )\n}\n","const ensureStaleTime = defaultedOptions => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n  }\n};\nconst willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nconst shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);\nconst fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({\n  data\n}) => {\n  defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);\n  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);\n}).catch(error => {\n  errorResetBoundary.clearReset();\n  defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);\n  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);\n});\n\nexport { ensureStaleTime, fetchOptimistic, shouldSuspend, willFetch };\n//# sourceMappingURL=suspense.mjs.map\n","'use client'\nimport * as React from 'react'\n\nimport { notifyManager } from '@tanstack/query-core'\nimport { useSyncExternalStore } from './useSyncExternalStore'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { ensureStaleTime, fetchOptimistic, shouldSuspend } from './suspense'\nimport type { QueryKey, QueryObserver } from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  ensureStaleTime(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange))\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      useErrorBoundary: defaultedOptions.useErrorBoundary,\n      query: observer.getCurrentQuery(),\n    })\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","'use client'\nimport { QueryObserver, parseQueryArgs } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type { QueryFunction, QueryKey } from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n","import { getDefaultState } from './mutation.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { shallowEqualObjects } from './utils.mjs';\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    var _this$currentMutation;\n\n    const prevOptions = this.options;\n    this.options = this.client.defaultMutationOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this\n      });\n    }\n\n    (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$currentMutation2;\n\n      (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const result = { ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions && this.hasListeners()) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n}\n\nexport { MutationObserver };\n//# sourceMappingURL=mutationObserver.mjs.map\n","'use client'\nimport * as React from 'react'\nimport {\n  MutationObserver,\n  notifyManager,\n  parseMutationArgs,\n} from '@tanstack/query-core'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport { useQueryClient } from './QueryClientProvider'\nimport { shouldThrowError } from './utils'\nimport type { MutationFunction, MutationKey } from '@tanstack/query-core'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","import { QueryObserver } from './queryObserver.mjs';\nimport { infiniteQueryBehavior, hasNextPage, hasPreviousPage } from './infiniteQueryBehavior.mjs';\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet, _state$data, _state$data2;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    const {\n      isFetching,\n      isRefetching\n    } = result;\n    const isFetchingNextPage = isFetching && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward';\n    const isFetchingPreviousPage = isFetching && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward';\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage\n    };\n  }\n\n}\n\nexport { InfiniteQueryObserver };\n//# sourceMappingURL=infiniteQueryObserver.mjs.map\n","'use client'\nimport { InfiniteQueryObserver, parseQueryArgs } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  QueryFunction,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport type { UseInfiniteQueryOptions, UseInfiniteQueryResult } from './types'\n\n// HOOK\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey' | 'queryFn'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1:\n    | TQueryKey\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg3?: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError> {\n  const options = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver as typeof QueryObserver,\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n","import { difference, replaceAt } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { QueryObserver } from './queryObserver.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = new Set();\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getQueries() {\n    return this.observers.map(observer => observer.getCurrentQuery());\n  }\n\n  getObservers() {\n    return this.observers;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const prevObserversMap = new Map(prevObservers.map(observer => [observer.options.queryHash, observer]));\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = new Set(matchingObservers.map(match => match.defaultedQueryOptions.queryHash));\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.has(defaultedOptions.queryHash));\n    const matchingObserversSet = new Set(matchingObservers.map(match => match.observer));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObserversSet.has(prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nexport { QueriesObserver };\n//# sourceMappingURL=queriesObserver.mjs.map\n","'use client'\nimport * as React from 'react'\n\nimport { QueriesObserver, notifyManager } from '@tanstack/query-core'\nimport { useSyncExternalStore } from './useSyncExternalStore'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type { QueryFunction, QueryKey } from '@tanstack/query-core'\nimport type { UseQueryOptions, UseQueryResult } from './types'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'context'>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const optimisticResult = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result, isRestoring),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const options = defaultedQueries[index]\n        const queryObserver = observer.getObservers()[index]\n\n        if (options && queryObserver) {\n          if (shouldSuspend(options, result, isRestoring)) {\n            return fetchOptimistic(options, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(options, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const observerQueries = observer.getQueries()\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) =>\n      getHasError({\n        result,\n        errorResetBoundary,\n        useErrorBoundary: defaultedQueries[index]?.useErrorBoundary ?? false,\n        query: observerQueries[index]!,\n      }),\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return optimisticResult as QueriesResults<T>\n}\n","import { createRecursiveProxy, createFlatProxy } from '@trpc/server/shared';\nimport { g as getArrayQueryKey } from './getArrayQueryKey-86134f8b.mjs';\nimport { createTRPCClientProxy, createTRPCClient } from '@trpc/client';\nimport { useQuery, useQueryClient, useMutation, hashQueryKey, useInfiniteQuery, useQueries } from '@tanstack/react-query';\nimport React, { createContext, useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * We treat `undefined` as an input the same as omitting an `input`\n * https://github.com/trpc/trpc/issues/2290\n */ function getQueryKeyInternal(path, input) {\n    if (path.length) return input === undefined ? [\n        path\n    ] : [\n        path,\n        input\n    ];\n    return [];\n}\n/**\n * Method to extract the query key for a procedure\n * @param procedureOrRouter - procedure or AnyRouter\n * @param input - input to procedureOrRouter\n * @param type - defaults to `any`\n * @link https://trpc.io/docs/getQueryKey\n */ function getQueryKey(..._params) {\n    const [procedureOrRouter, input, type] = _params;\n    // @ts-expect-error - we don't expose _def on the type layer\n    const path = procedureOrRouter._def().path;\n    const dotPath = path.join('.');\n    const queryKey = getArrayQueryKey(getQueryKeyInternal(dotPath, input), type ?? 'any');\n    return queryKey;\n}\n\n/**\n * Create proxy for decorating procedures\n * @internal\n */ function createReactProxyDecoration(name, hooks) {\n    return createRecursiveProxy((opts)=>{\n        const args = opts.args;\n        const pathCopy = [\n            name,\n            ...opts.path\n        ];\n        // The last arg is for instance `.useMutation` or `.useQuery()`\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const lastArg = pathCopy.pop();\n        // The `path` ends up being something like `post.byId`\n        const path = pathCopy.join('.');\n        if (lastArg === 'useMutation') {\n            return hooks[lastArg](path, ...args);\n        }\n        const [input, ...rest] = args;\n        const queryKey = getQueryKeyInternal(path, input);\n        // Expose queryKey helper\n        if (lastArg === 'getQueryKey') {\n            return getArrayQueryKey(queryKey, rest[0] ?? 'any');\n        }\n        if (lastArg === '_def') {\n            return {\n                path: pathCopy\n            };\n        }\n        if (lastArg.startsWith('useSuspense')) {\n            const opts1 = rest[0] || {};\n            const fn = lastArg === 'useSuspenseQuery' ? 'useQuery' : 'useInfiniteQuery';\n            const result = hooks[fn](queryKey, {\n                ...opts1,\n                suspense: true,\n                enabled: true\n            });\n            return [\n                result.data,\n                result\n            ];\n        }\n        return hooks[lastArg](queryKey, ...rest);\n    });\n}\n\nconst contextProps = [\n    'client',\n    'ssrContext',\n    'ssrState',\n    'abortOnUnmount'\n];\nconst TRPCContext = /*#__PURE__*/ createContext(null);\n\n/**\n * @internal\n */ function createReactQueryUtilsProxy(context) {\n    return createFlatProxy((key)=>{\n        const contextName = key;\n        if (contextName === 'client') {\n            return createTRPCClientProxy(context.client);\n        }\n        if (contextProps.includes(contextName)) {\n            return context[contextName];\n        }\n        return createRecursiveProxy(({ path , args  })=>{\n            const pathCopy = [\n                key,\n                ...path\n            ];\n            const utilName = pathCopy.pop();\n            const fullPath = pathCopy.join('.');\n            const getOpts = (name)=>{\n                if ([\n                    'setData',\n                    'setInfiniteData'\n                ].includes(name)) {\n                    const [input, updater, ...rest] = args;\n                    const queryKey = getQueryKeyInternal(fullPath, input);\n                    return {\n                        queryKey,\n                        updater,\n                        rest\n                    };\n                }\n                const [input1, ...rest1] = args;\n                const queryKey1 = getQueryKeyInternal(fullPath, input1);\n                return {\n                    queryKey: queryKey1,\n                    rest: rest1\n                };\n            };\n            const { queryKey , rest , updater  } = getOpts(utilName);\n            const contextMap = {\n                fetch: ()=>context.fetchQuery(queryKey, ...rest),\n                fetchInfinite: ()=>context.fetchInfiniteQuery(queryKey, ...rest),\n                prefetch: ()=>context.prefetchQuery(queryKey, ...rest),\n                prefetchInfinite: ()=>context.prefetchInfiniteQuery(queryKey, ...rest),\n                ensureData: ()=>context.ensureQueryData(queryKey, ...rest),\n                invalidate: ()=>context.invalidateQueries(queryKey, ...rest),\n                reset: ()=>context.resetQueries(queryKey, ...rest),\n                refetch: ()=>context.refetchQueries(queryKey, ...rest),\n                cancel: ()=>context.cancelQuery(queryKey, ...rest),\n                setData: ()=>{\n                    context.setQueryData(queryKey, updater, ...rest);\n                },\n                setInfiniteData: ()=>{\n                    context.setInfiniteQueryData(queryKey, updater, ...rest);\n                },\n                getData: ()=>context.getQueryData(queryKey),\n                getInfiniteData: ()=>context.getInfiniteQueryData(queryKey)\n            };\n            return contextMap[utilName]();\n        });\n    });\n}\n\n/**\n * Create proxy for `useQueries` options\n * @internal\n */ function createUseQueriesProxy(client) {\n    return createRecursiveProxy((opts)=>{\n        const path = opts.path.join('.');\n        const [input, _opts] = opts.args;\n        const queryKey = getQueryKeyInternal(path, input);\n        const options = {\n            queryKey,\n            queryFn: ()=>{\n                return client.query(path, input, _opts?.trpc);\n            },\n            ..._opts\n        };\n        return options;\n    });\n}\n\nfunction getClientArgs(pathAndInput, opts) {\n    const [path, input] = pathAndInput;\n    return [\n        path,\n        input,\n        opts?.trpc\n    ];\n}\n\n/**\n * Makes a stable reference of the `trpc` prop\n */ function useHookResult(value) {\n    const ref = useRef(value);\n    ref.current.path = value.path;\n    return ref.current;\n}\n\n/**\n * @internal\n */ function createRootHooks(config) {\n    const mutationSuccessOverride = (config?.overrides ?? config?.unstable_overrides)?.useMutation?.onSuccess ?? ((options)=>options.originalFn());\n    const Context = config?.context ?? TRPCContext;\n    const ReactQueryContext = config?.reactQueryContext;\n    const createClient = (opts)=>{\n        return createTRPCClient(opts);\n    };\n    const TRPCProvider = (props)=>{\n        const { abortOnUnmount =false , client , queryClient , ssrContext  } = props;\n        const [ssrState, setSSRState] = useState(props.ssrState ?? false);\n        useEffect(()=>{\n            // Only updating state to `mounted` if we are using SSR.\n            // This makes it so we don't have an unnecessary re-render when opting out of SSR.\n            setSSRState((state)=>state ? 'mounted' : false);\n        }, []);\n        return /*#__PURE__*/ React.createElement(Context.Provider, {\n            value: {\n                abortOnUnmount,\n                queryClient,\n                client,\n                ssrContext: ssrContext ?? null,\n                ssrState,\n                fetchQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.fetchQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'query'),\n                        queryFn: ()=>client.query(...getClientArgs(pathAndInput, opts))\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                fetchInfiniteQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.fetchInfiniteQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n                        queryFn: ({ pageParam  })=>{\n                            const [path, input] = pathAndInput;\n                            const actualInput = {\n                                ...input,\n                                cursor: pageParam\n                            };\n                            return client.query(...getClientArgs([\n                                path,\n                                actualInput\n                            ], opts));\n                        }\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                prefetchQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.prefetchQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'query'),\n                        queryFn: ()=>client.query(...getClientArgs(pathAndInput, opts))\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                prefetchInfiniteQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.prefetchInfiniteQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n                        queryFn: ({ pageParam  })=>{\n                            const [path, input] = pathAndInput;\n                            const actualInput = {\n                                ...input,\n                                cursor: pageParam\n                            };\n                            return client.query(...getClientArgs([\n                                path,\n                                actualInput\n                            ], opts));\n                        }\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                ensureQueryData: useCallback((pathAndInput, opts)=>{\n                    return queryClient.ensureQueryData({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'query'),\n                        queryFn: ()=>client.query(...getClientArgs(pathAndInput, opts))\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                invalidateQueries: useCallback((queryKey, filters, options)=>{\n                    return queryClient.invalidateQueries({\n                        ...filters,\n                        queryKey: getArrayQueryKey(queryKey, 'any')\n                    }, options);\n                }, [\n                    queryClient\n                ]),\n                resetQueries: useCallback((...args)=>{\n                    const [queryKey, filters, options] = args;\n                    return queryClient.resetQueries({\n                        ...filters,\n                        queryKey: getArrayQueryKey(queryKey, 'any')\n                    }, options);\n                }, [\n                    queryClient\n                ]),\n                refetchQueries: useCallback((...args)=>{\n                    const [queryKey, filters, options] = args;\n                    return queryClient.refetchQueries({\n                        ...filters,\n                        queryKey: getArrayQueryKey(queryKey, 'any')\n                    }, options);\n                }, [\n                    queryClient\n                ]),\n                cancelQuery: useCallback((pathAndInput)=>{\n                    return queryClient.cancelQueries({\n                        queryKey: getArrayQueryKey(pathAndInput, 'any')\n                    });\n                }, [\n                    queryClient\n                ]),\n                setQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.setQueryData(getArrayQueryKey(queryKey, 'query'), ...rest);\n                }, [\n                    queryClient\n                ]),\n                getQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.getQueryData(getArrayQueryKey(queryKey, 'query'), ...rest);\n                }, [\n                    queryClient\n                ]),\n                setInfiniteQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.setQueryData(getArrayQueryKey(queryKey, 'infinite'), ...rest);\n                }, [\n                    queryClient\n                ]),\n                getInfiniteQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.getQueryData(getArrayQueryKey(queryKey, 'infinite'), ...rest);\n                }, [\n                    queryClient\n                ])\n            }\n        }, props.children);\n    };\n    function useContext() {\n        return React.useContext(Context);\n    }\n    /**\n   * Hack to make sure errors return `status`='error` when doing SSR\n   * @link https://github.com/trpc/trpc/pull/1645\n   */ function useSSRQueryOptionsIfNeeded(pathAndInput, type, opts) {\n        const { queryClient , ssrState  } = useContext();\n        return ssrState && ssrState !== 'mounted' && queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, type))?.state.status === 'error' ? {\n            retryOnMount: false,\n            ...opts\n        } : opts;\n    }\n    function useQuery$1(// FIXME path should be a tuple in next major\n    pathAndInput, opts) {\n        const context = useContext();\n        if (!context) {\n            throw new Error('Unable to retrieve application context. Did you forget to wrap your App inside `withTRPC` HoC?');\n        }\n        const { abortOnUnmount , client , ssrState , queryClient , prefetchQuery  } = context;\n        const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, 'query'));\n        if (typeof window === 'undefined' && ssrState === 'prepass' && opts?.trpc?.ssr !== false && (opts?.enabled ?? defaultOpts?.enabled) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, 'query'))) {\n            void prefetchQuery(pathAndInput, opts);\n        }\n        const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, 'query', {\n            ...defaultOpts,\n            ...opts\n        });\n        const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? config?.abortOnUnmount ?? abortOnUnmount;\n        const hook = useQuery({\n            ...ssrOpts,\n            queryKey: getArrayQueryKey(pathAndInput, 'query'),\n            queryFn: (queryFunctionContext)=>{\n                const actualOpts = {\n                    ...ssrOpts,\n                    trpc: {\n                        ...ssrOpts?.trpc,\n                        ...shouldAbortOnUnmount ? {\n                            signal: queryFunctionContext.signal\n                        } : {}\n                    }\n                };\n                return client.query(...getClientArgs(pathAndInput, actualOpts));\n            },\n            context: ReactQueryContext\n        });\n        hook.trpc = useHookResult({\n            path: pathAndInput[0]\n        });\n        return hook;\n    }\n    function useMutation$1(// FIXME: this should only be a tuple path in next major\n    path, opts) {\n        const { client  } = useContext();\n        const queryClient = useQueryClient({\n            context: ReactQueryContext\n        });\n        const actualPath = Array.isArray(path) ? path[0] : path;\n        const defaultOpts = queryClient.getMutationDefaults([\n            actualPath.split('.')\n        ]);\n        const hook = useMutation({\n            ...opts,\n            mutationKey: [\n                actualPath.split('.')\n            ],\n            mutationFn: (input)=>{\n                return client.mutation(...getClientArgs([\n                    actualPath,\n                    input\n                ], opts));\n            },\n            context: ReactQueryContext,\n            onSuccess (...args) {\n                const originalFn = ()=>opts?.onSuccess?.(...args) ?? defaultOpts?.onSuccess?.(...args);\n                return mutationSuccessOverride({\n                    originalFn,\n                    queryClient,\n                    meta: opts?.meta ?? defaultOpts?.meta ?? {}\n                });\n            }\n        });\n        hook.trpc = useHookResult({\n            path: actualPath\n        });\n        return hook;\n    }\n    /* istanbul ignore next -- @preserve */ function useSubscription(pathAndInput, opts) {\n        const enabled = opts?.enabled ?? true;\n        const queryKey = hashQueryKey(pathAndInput);\n        const { client  } = useContext();\n        const optsRef = useRef(opts);\n        optsRef.current = opts;\n        useEffect(()=>{\n            if (!enabled) {\n                return;\n            }\n            const [path, input] = pathAndInput;\n            let isStopped = false;\n            const subscription = client.subscription(path, input ?? undefined, {\n                onStarted: ()=>{\n                    if (!isStopped) {\n                        optsRef.current.onStarted?.();\n                    }\n                },\n                onData: (data)=>{\n                    if (!isStopped) {\n                        // FIXME this shouldn't be needed as both should be `unknown` in next major\n                        optsRef.current.onData(data);\n                    }\n                },\n                onError: (err)=>{\n                    if (!isStopped) {\n                        optsRef.current.onError?.(err);\n                    }\n                }\n            });\n            return ()=>{\n                isStopped = true;\n                subscription.unsubscribe();\n            };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            queryKey,\n            enabled\n        ]);\n    }\n    function useInfiniteQuery$1(pathAndInput, opts) {\n        const [path, input] = pathAndInput;\n        const { client , ssrState , prefetchInfiniteQuery , queryClient , abortOnUnmount ,  } = useContext();\n        const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, 'infinite'));\n        if (typeof window === 'undefined' && ssrState === 'prepass' && opts?.trpc?.ssr !== false && (opts?.enabled ?? defaultOpts?.enabled) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, 'infinite'))) {\n            void prefetchInfiniteQuery(pathAndInput, {\n                ...defaultOpts,\n                ...opts\n            });\n        }\n        const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, 'infinite', {\n            ...defaultOpts,\n            ...opts\n        });\n        // request option should take priority over global\n        const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? abortOnUnmount;\n        const hook = useInfiniteQuery({\n            ...ssrOpts,\n            queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n            queryFn: (queryFunctionContext)=>{\n                const actualOpts = {\n                    ...ssrOpts,\n                    trpc: {\n                        ...ssrOpts?.trpc,\n                        ...shouldAbortOnUnmount ? {\n                            signal: queryFunctionContext.signal\n                        } : {}\n                    }\n                };\n                const actualInput = {\n                    ...input ?? {},\n                    cursor: queryFunctionContext.pageParam ?? opts?.initialCursor\n                };\n                // FIXME as any shouldn't be needed as client should be untyped too\n                return client.query(...getClientArgs([\n                    path,\n                    actualInput\n                ], actualOpts));\n            },\n            context: ReactQueryContext\n        });\n        hook.trpc = useHookResult({\n            path\n        });\n        return hook;\n    }\n    const useQueries$1 = (queriesCallback, context)=>{\n        const { ssrState , queryClient , prefetchQuery , client  } = useContext();\n        const proxy = createUseQueriesProxy(client);\n        const queries = queriesCallback(proxy);\n        if (typeof window === 'undefined' && ssrState === 'prepass') {\n            for (const query of queries){\n                const queryOption = query;\n                if (queryOption.trpc?.ssr !== false && !queryClient.getQueryCache().find(getArrayQueryKey(queryOption.queryKey, 'query'))) {\n                    void prefetchQuery(queryOption.queryKey, queryOption);\n                }\n            }\n        }\n        return useQueries({\n            queries: queries.map((query)=>({\n                    ...query,\n                    queryKey: getArrayQueryKey(query.queryKey, 'query')\n                })),\n            context\n        });\n    };\n    const useDehydratedState = (client, trpcState)=>{\n        const transformed = useMemo(()=>{\n            if (!trpcState) {\n                return trpcState;\n            }\n            return client.runtime.transformer.deserialize(trpcState);\n        }, [\n            trpcState,\n            client\n        ]);\n        return transformed;\n    };\n    return {\n        Provider: TRPCProvider,\n        createClient,\n        useContext,\n        useUtils: useContext,\n        useQuery: useQuery$1,\n        useQueries: useQueries$1,\n        useMutation: useMutation$1,\n        useSubscription,\n        useDehydratedState,\n        useInfiniteQuery: useInfiniteQuery$1\n    };\n}\n\n/**\n * Create strongly typed react hooks\n * @internal\n * @deprecated\n */ function createHooksInternal(config) {\n    return createRootHooks(config);\n}\n\nexport { TRPCContext as T, createReactQueryUtilsProxy as a, createReactProxyDecoration as b, createHooksInternal as c, getClientArgs as d, createUseQueriesProxy as e, createRootHooks as f, getQueryKey as g, contextProps as h };\n","export * from '@trpc/client';\nimport { c as createHooksInternal, a as createReactQueryUtilsProxy, b as createReactProxyDecoration } from './createHooksInternal-bdff7171.mjs';\nexport { g as getQueryKey } from './createHooksInternal-bdff7171.mjs';\nimport { createFlatProxy } from '@trpc/server/shared';\nimport { useMemo } from 'react';\nimport '@tanstack/react-query';\nimport './getArrayQueryKey-86134f8b.mjs';\n\n/**\n * @internal\n */ function createHooksInternalProxy(trpc) {\n    return createFlatProxy((key)=>{\n        if (key === 'useContext' || key === 'useUtils') {\n            return ()=>{\n                const context = trpc.useUtils();\n                // create a stable reference of the utils context\n                return useMemo(()=>{\n                    return createReactQueryUtilsProxy(context);\n                }, [\n                    context\n                ]);\n            };\n        }\n        if (trpc.hasOwnProperty(key)) {\n            return trpc[key];\n        }\n        return createReactProxyDecoration(key, trpc);\n    });\n}\nfunction createTRPCReact(opts) {\n    const hooks = createHooksInternal(opts);\n    const proxy = createHooksInternalProxy(hooks);\n    return proxy;\n}\n\n// interop:\n/**\n * @deprecated use `createTRPCReact` instead\n */ function createReactQueryHooks(opts) {\n    const trpc = createHooksInternal(opts);\n    const proxy = createHooksInternalProxy(trpc);\n    return {\n        ...trpc,\n        proxy\n    };\n}\n\nexport { createReactQueryHooks, createTRPCReact };\n","/**\n * @internal\n */ function invert(obj) {\n    const newObj = Object.create(null);\n    for(const key in obj){\n        const v = obj[key];\n        newObj[v] = key;\n    }\n    return newObj;\n}\n\n// reference: https://www.jsonrpc.org/specification\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */ const TRPC_ERROR_CODES_BY_KEY = {\n    /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */ PARSE_ERROR: -32700,\n    /**\n   * The JSON sent is not a valid Request object.\n   */ BAD_REQUEST: -32600,\n    // Internal JSON-RPC error\n    INTERNAL_SERVER_ERROR: -32603,\n    NOT_IMPLEMENTED: -32603,\n    // Implementation specific errors\n    UNAUTHORIZED: -32001,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    UNPROCESSABLE_CONTENT: -32022,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\nconst TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);\n\nexport { TRPC_ERROR_CODES_BY_KEY as T, TRPC_ERROR_CODES_BY_NUMBER as a, invert as i };\n","import { i as invert, T as TRPC_ERROR_CODES_BY_KEY } from './codes-c924c3db.mjs';\n\nconst TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);\nconst JSONRPC2_TO_HTTP_CODE = {\n    PARSE_ERROR: 400,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    NOT_FOUND: 404,\n    FORBIDDEN: 403,\n    METHOD_NOT_SUPPORTED: 405,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    UNPROCESSABLE_CONTENT: 422,\n    TOO_MANY_REQUESTS: 429,\n    CLIENT_CLOSED_REQUEST: 499,\n    INTERNAL_SERVER_ERROR: 500,\n    NOT_IMPLEMENTED: 501\n};\nfunction getStatusCodeFromKey(code) {\n    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\nfunction getHTTPStatusCode(json) {\n    const arr = Array.isArray(json) ? json : [\n        json\n    ];\n    const httpStatuses = new Set(arr.map((res)=>{\n        if ('error' in res) {\n            const data = res.error.data;\n            if (typeof data.httpStatus === 'number') {\n                return data.httpStatus;\n            }\n            const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n            return getStatusCodeFromKey(code);\n        }\n        return 200;\n    }));\n    if (httpStatuses.size !== 1) {\n        return 207;\n    }\n    const httpStatus = httpStatuses.values().next().value;\n    return httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n    return getStatusCodeFromKey(error.code);\n}\n\nconst noop = ()=>{\n// noop\n};\nfunction createInnerProxy(callback, path) {\n    const proxy = new Proxy(noop, {\n        get (_obj, key) {\n            if (typeof key !== 'string' || key === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return createInnerProxy(callback, [\n                ...path,\n                key\n            ]);\n        },\n        apply (_1, _2, args) {\n            const isApply = path[path.length - 1] === 'apply';\n            return callback({\n                args: isApply ? args.length >= 2 ? args[1] : [] : args,\n                path: isApply ? path.slice(0, -1) : path\n            });\n        }\n    });\n    return proxy;\n}\n/**\n * Creates a proxy that calls the callback with the path and arguments\n *\n * @internal\n */ const createRecursiveProxy = (callback)=>createInnerProxy(callback, []);\n/**\n * Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n *\n * @internal\n */ const createFlatProxy = (callback)=>{\n    return new Proxy(noop, {\n        get (_obj, name) {\n            if (typeof name !== 'string' || name === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return callback(name);\n        }\n    });\n};\n\nexport { TRPC_ERROR_CODES_BY_NUMBER as T, createRecursiveProxy as a, getHTTPStatusCode as b, createFlatProxy as c, getHTTPStatusCodeFromError as g };\n","import { g as getHTTPStatusCodeFromError } from './index-f91d720c.mjs';\nimport { T as TRPC_ERROR_CODES_BY_KEY } from './codes-c924c3db.mjs';\n\n/**\n * @internal\n */ function getErrorShape(opts) {\n    const { path , error , config  } = opts;\n    const { code  } = opts.error;\n    const shape = {\n        message: error.message,\n        code: TRPC_ERROR_CODES_BY_KEY[code],\n        data: {\n            code,\n            httpStatus: getHTTPStatusCodeFromError(error)\n        }\n    };\n    if (config.isDev && typeof opts.error.stack === 'string') {\n        shape.data.stack = opts.error.stack;\n    }\n    if (typeof path === 'string') {\n        shape.data.path = path;\n    }\n    return config.errorFormatter({\n        ...opts,\n        shape\n    });\n}\n\nfunction transformTRPCResponseItem(config, item) {\n    if ('error' in item) {\n        return {\n            ...item,\n            error: config.transformer.output.serialize(item.error)\n        };\n    }\n    if ('data' in item.result) {\n        return {\n            ...item,\n            result: {\n                ...item.result,\n                data: config.transformer.output.serialize(item.result.data)\n            }\n        };\n    }\n    return item;\n}\n/**\n * Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n **/ function transformTRPCResponse(config, itemOrItems) {\n    return Array.isArray(itemOrItems) ? itemOrItems.map((item)=>transformTRPCResponseItem(config, item)) : transformTRPCResponseItem(config, itemOrItems);\n}\n\nexport { getErrorShape as g, transformTRPCResponse as t };\n","/**\n * @internal\n */ function isObject(value) {\n    // check that value is object\n    return !!value && !Array.isArray(value) && typeof value === 'object';\n}\n\nclass UnknownCauseError extends Error {\n}\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    const type = typeof cause;\n    if (type === 'undefined' || type === 'function' || cause === null) {\n        return undefined;\n    }\n    // Primitive types just get wrapped in an error\n    if (type !== 'object') {\n        return new Error(String(cause));\n    }\n    // If it's an object, we'll create a synthetic error\n    if (isObject(cause)) {\n        const err = new UnknownCauseError();\n        for(const key in cause){\n            err[key] = cause[key];\n        }\n        return err;\n    }\n    return undefined;\n}\n\nexport { getCauseFromUnknown as g };\n","export { c as createFlatProxy, a as createRecursiveProxy } from '../index-f91d720c.mjs';\nexport { g as getErrorShape, t as transformTRPCResponse } from '../transformTRPCResponse-1153b421.mjs';\nexport { g as getCauseFromUnknown } from '../getCauseFromUnknown-2d66414a.mjs';\nimport '../codes-c924c3db.mjs';\n"],"names":["addLocale","path","args","getDomainLocale","locale","locales","domainLocales","_interop_require_default","_","require","prefetched","Set","router","prefetch","window","href","as","options","appOptions","isAppRouter","_islocalurl","isLocalURL","prefetchedKey","has","add","process","env","formatStringOrUrl","urlObjOrString","_formaturl","formatUrl","children","legacyBehavior","childrenProp","a","appRouter","React","useContext","AppRouterContext","pagesRouter","prefetchEnabled","prefetchProp","_routerreducertypes","PrefetchKind","AUTO","FULL","default","useMemo","resolvedHref","hrefProp","asProp","resolvedAs","_resolvehref","resolveHref","previousAs","useRef","_react","child","Children","only","childRef","setIntersectionRef","isVisible","resetVisible","useIntersection","rootMargin","_useintersection","setRef","useCallback","previousHref","current","el","useEffect","appPrefetchKind","ref","onClick","e","props","defaultPrevented","linkClicked","currentTarget","replace","shallow","scroll","nodeName","isModifiedEvent","event","target","eventTarget","nativeEvent","which","metaKey","ctrlKey","shiftKey","altKey","preventDefault","navigate","routerScroll","startTransition","onMouseEnter","onMouseEnterProp","priority","bypassPrefetchedCheck","onTouchStart","onTouchStartProp","childProps","curLocale","type","localeDomain","addBasePath","_getdomainlocale","defaultLocale","_addbasepath","_addlocale","restProps","cloneElement","_jsxruntime","jsx","cancelIdleCallback","requestIdleCallback","self","bind","cb","start","Date","now","setTimeout","didTimeout","timeRemaining","Math","max","id","clearTimeout","resolveAs","base","urlAsString","formatWithValidation","urlProtoMatch","match","urlAsStringNoProto","slice","length","urlParts","split","console","error","pathname","normalizedUrl","normalizeRepeatedSlashes","URL","startsWith","asPath","finalUrl","normalizePathTrailingSlash","interpolatedAs","isDynamicRoute","searchParams","query","searchParamsToUrlQuery","result","params","interpolateAs","hash","omit","origin","hasIntersectionObserver","IntersectionObserver","observers","Map","idList","param","rootRef","disabled","isDisabled","visible","setVisible","useState","elementRef","setElement","element","tagName","observe","callback","observer","elements","createObserver","instance","root","margin","existing","find","obj","get","entries","forEach","entry","isIntersecting","intersectionRatio","push","set","delete","unobserve","size","disconnect","index","findIndex","splice","idleCallback","escapeStringRegexp","reHasRegExp","reReplaceRegExp","str","test","RouterContext","createContext","urlObjectKeys","slashedProtocols","urlObj","auth","hostname","protocol","host","encodeURIComponent","indexOf","port","String","querystring","urlQueryToSearchParams","search","endsWith","slashes","url","getSortedRoutes","route","asPathname","interpolatedRoute","dynamicRegex","getRouteRegex","dynamicGroups","groups","dynamicMatches","getRouteMatcher","Object","keys","every","value","repeat","optional","replaced","Array","isArray","map","segment","join","TEST_ROUTE","isInterceptionRouteAppPath","extractInterceptionRouteInformation","interceptedRoute","isAbsoluteUrl","locationOrigin","getLocationOrigin","resolved","hasBasePath","object","omitted","includes","key","stringifyUrlQueryParam","isNaN","urlQuery","URLSearchParams","append","item","assign","_len","arguments","searchParamsList","_key","from","re","routeMatch","exec","decode","decodeURIComponent","DecodeError","g","slugName","m","pos","undefined","getNamedMiddlewareRegex","getNamedRouteRegex","parseParameter","getParametrizedRoute","segments","removeTrailingSlash","groupIndex","parameterizedRoute","markerMatch","INTERCEPTION_ROUTE_MARKERS","paramMatches","normalizedRoute","getSafeKeyFromSegment","interceptionMarker","getSafeRouteKey","routeKeys","keyPrefix","cleanedKey","invalidKey","parseInt","interceptionPrefix","getNamedParametrizedRoute","prefixRouteKeys","i","routeKey","j","fromCharCode","floor","namedParameterizedRoute","hasInterceptionMarker","some","usedMarker","prefixRouteKey","namedRegex","catchAll","UrlNode","insert","urlPath","_insert","filter","Boolean","smoosh","_smoosh","prefix","childrenPaths","sort","restSlugName","optionalRestSlugName","routes","c","reduce","prev","curr","placeholder","r","unshift","urlPaths","slugNames","isCatchAll","nextSegment","segmentName","isOptional","substring","handleSlug","previousSlug","nextSlug","slug","normalizedPages","pagePath","MiddlewareNotFoundError","MissingStaticPage","NormalizeError","PageNotFoundError","SP","ST","WEB_VITALS","execOnce","getDisplayName","getURL","isResSent","loadGetInitialProps","stringifyError","fn","used","ABSOLUTE_URL_REGEX","location","Component","displayName","name","res","finished","headersSent","urlNoQuery","App","ctx","getInitialProps","pageProps","performance","method","Error","constructor","page","code","message","JSON","stringify","stack","__webpack_require__","k","is","b","l","n","useLayoutEffect","p","useDebugValue","getSnapshot","d","f","u","document","createElement","inst","exports","useSyncExternalStore","module","FocusManager","_subscribable_mjs__WEBPACK_IMPORTED_MODULE_0__","setup","onFocus","_utils_mjs__WEBPACK_IMPORTED_MODULE_1__","sk","addEventListener","listener","removeEventListener","onSubscribe","cleanup","setEventListener","onUnsubscribe","hasListeners","_this$cleanup","call","_this$cleanup2","focused","setFocused","listeners","isFocused","visibilityState","focusManager","infiniteQueryBehavior","onFetch","context","fetchFn","_context$fetchOptions","_context$fetchOptions2","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","promise","refetchPage","fetchOptions","meta","fetchMore","pageParam","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","state","data","pages","oldPageParams","pageParams","newPageParams","cancelled","addSignalProperty","defineProperty","enumerable","_context$signal","_context$signal2","signal","aborted","queryFn","Promise","reject","queryHash","buildNewPages","previous","fetchPage","manual","resolve","queryFnContext","queryKey","then","getNextPageParam","getPreviousPageParam","shouldFetchFirstPage","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","defaultLogger","Mutation","_removable_mjs__WEBPACK_IMPORTED_MODULE_0__","F","config","defaultOptions","mutationId","mutationCache","logger","_logger_mjs__WEBPACK_IMPORTED_MODULE_1__","getDefaultState","setOptions","scheduleGc","updateCacheTime","cacheTime","setState","dispatch","addObserver","clearGcTimeout","notify","mutation","removeObserver","x","optionalRemove","status","remove","continue","_this$retryer$continu","_this$retryer","retryer","execute","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","_this$mutationCache$c7","_this$mutationCache$c8","_this$options$onError","_this$options4","_this$mutationCache$c9","_this$mutationCache$c10","_this$options$onSettl2","_this$options5","restored","variables","onMutate","executeMutation","_this$options$retry","_retryer_mjs__WEBPACK_IMPORTED_MODULE_2__","Mz","mutationFn","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","onSuccess","onSettled","onError","action","reducer","failureReason","isPaused","Kw","_notifyManager_mjs__WEBPACK_IMPORTED_MODULE_3__","V","batch","onMutationUpdate","notifyManager","createNotifyManager","queue","transactions","notifyFn","batchNotifyFn","schedule","_utils_mjs__WEBPACK_IMPORTED_MODULE_0__","A4","flush","originalQueue","batchCalls","setNotifyFunction","setBatchNotifyFunction","onlineEvents","OnlineManager","onOnline","online","setOnline","isOnline","navigator","onLine","onlineManager","Removable","destroy","PN","gcTimeout","newCacheTime","Infinity","defaultRetryDelay","min","canFetch","_onlineManager_mjs__WEBPACK_IMPORTED_MODULE_0__","N","CancelledError","revert","silent","isCancelledError","createRetryer","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","outerResolve","outerReject","shouldPause","_focusManager_mjs__WEBPACK_IMPORTED_MODULE_1__","pause","continueResolve","canContinue","run","promiseOrValue","catch","_config$retry","_config$retryDelay","delay","shouldRetry","_utils_mjs__WEBPACK_IMPORTED_MODULE_2__","Gh","cancel","cancelOptions","abort","didContinue","cancelRetry","continueRetry","Subscribable","subscribe","identity","isServer","noop","functionalUpdate","updater","input","isValidTimeout","difference","array1","array2","replaceAt","array","copy","timeUntilStale","updatedAt","staleTime","parseQueryArgs","arg1","arg2","arg3","parseMutationArgs","mutationKey","parseFilterArgs","isQueryKey","matchQuery","filters","exact","fetchStatus","predicate","stale","hashQueryKeyByOptions","partialDeepEqual","isActive","isStale","matchMutation","fetching","hashQueryKey","hashFn","queryKeyHashFn","val","isPlainObject","partialMatchKey","shallowEqualObjects","isPlainArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","sleep","timeout","scheduleMicrotask","getAbortController","AbortController","replaceData","prevData","isDataEqual","structuralSharing","replaceEqualDeep","aSize","bItems","bSize","equalItems","defaultContext","QueryClientSharingContext","getQueryClientContext","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","QueryClientProvider","client","Context","observable_ade1bad8_observable","teardownRef","isDone","unsubscribed","teardownImmediately","unsubscribe","next","err","complete","pipe","operations","pipeFromArray","fns","ObservableAbortError","setPrototypeOf","isObject","TransformResultError","transformResult_ace864b8_transformResult","response","runtime","transformResultInner","transformer","deserialize","ok","TRPCClientError_38f9a32a_TRPCClientError","_cause","opts","cause","shared","sZ","shape","isFunction","resolveHTTPLinkOptions","customAbortControllerImpl","fetch","globalThis","METHOD","getInput","serialize","arrayToDict","dict","inputs","_input","getUrl","queryParts","getBody","jsonHttpRequester","httpRequest","contentTypeHeader","fetchHTTPResponse","ac","body","resolvedHeaders","headers","batchModeHeader","getFetch","customFetchImpl","done","_res","json","responseJSON","throwFatalError","dataLoader","batchLoader","pendingItems","dispatchTimer","destroyTimerAndPendingItems","groupedItems","groupItems","items","lastGroup","validate","concat","it","unitResolver","_item","load","createHTTPBatchLink","requester","resolvedOpts","maxURLLength","batchOps","op","loaders","subscription","loader","transformed","httpBatchLink","requesterOpts","opList","resJSON","httpLinkFactory","factoryOpts","TRPCUntypedClient","$request","chain$","links","requestId","obs$","nextOp","refCount","originalObserver","resetIfNeeded","_sub","v","requestAsPromise","observable","onDone","envelope","observable$","onStarted","onStopped","onData","onComplete","combinedTransformer","output","link","createTRPCClient","clientCallTypeMap","mutate","clientCallTypeToProcedureType","clientCallType","createTRPCClientProxy","yh","IX","pathCopy","procedureType","pop","fullPath","parseJSONStream","parse","readLines","readableStream","line","indexOfColon","indexAsStr","text","onSingle","Number","textDecoder","partOfLine","onChunk","chunkLines","chunkText","chunk","readStandardChunks","stream","on","reader","getReader","readResult","read","streamingJsonHttpRequester","responsePromise","string","getTextDecoder","customTextDecoder","TextDecoder","dist_getBody","FormData","getArrayQueryKey_86134f8b_getArrayQueryKey","arrayPath","QueryObserver","subscribable","trackedProps","selectError","bindMethods","refetch","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","notifyOptions","prevOptions","prevQuery","defaultQueryOptions","utils","VS","getQueryCache","enabled","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","build","createResult","keepPreviousData","placeholderData","optimisticResult","isPlaceholderData","getCurrentResult","currentResult","currentResultOptions","currentResultState","trackResult","trackedResult","configurable","getCurrentQuery","fetchOptimistic","defaultedOptions","isFetchingOptimistic","_fetchOptions$cancelR","cancelRefetch","throwOnError","ZT","time","Kp","dataUpdatedAt","staleTimeoutId","_this$options$refetch","refetchInterval","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","errorUpdatedAt","isPreviousData","_optimisticResults","fetchOnMount","fetchOptionally","isSuccess","select","selectFn","selectResult","oE","isFetching","isLoading","isError","isInitialLoading","fetchFailureCount","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","defaultNotifyOptions","cache","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","useErrorBoundary","changed","onQueryUpdate","DV","retryOnMount","refetchOnMount","field","suspense","isStaleByTime","useSyncExternalStore$1","QueryErrorResetBoundaryContext","clearReset","isReset","reset","useQueryErrorResetBoundary","IsRestoringContext","useIsRestoring","shouldThrowError","_useErrorBoundary","IsRestoringProvider","errorResetBoundary","useClearResetErrorBoundary","getHasError","ensureStaleTime","willFetch","isRestoring","shouldSuspend","useBaseQuery","Observer","ensurePreventErrorBoundaryRetry","onStoreChange","MutationObserver","_this$currentMutation","defaultMutationOptions","getMutationCache","currentMutation","_this$currentMutation2","mutateOptions","R","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","InfiniteQueryObserver","fetchNextPage","fetchPreviousPage","behavior","Gm","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","_state$data","_state$data2","fetchMeta","Qy","ZF","QueriesObserver","queries","observersMap","setQueries","onUpdate","prevObservers","newObserverMatches","findMatchingObservers","defaultedQueryOptions","newObservers","newObserversMap","fromEntries","newResult","hasIndexChange","e5","getQueries","getObservers","prevObserversMap","matchingObservers","flatMap","matchedQueryHashes","unmatchedQueries","matchingObserversSet","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","previouslyUsedObserver","Rc","getQueryKeyInternal","contextProps","TRPCContext","react","getClientArgs","pathAndInput","trpc","useHookResult","createTRPCReact","createRootHooks","mutationSuccessOverride","overrides","unstable_overrides","useMutation","originalFn","ReactQueryContext","reactQueryContext","useSSRQueryOptionsIfNeeded","ssrState","Provider","abortOnUnmount","ssrContext","setSSRState","fetchQuery","fetchInfiniteQuery","actualInput","cursor","prefetchQuery","prefetchInfiniteQuery","ensureQueryData","invalidateQueries","resetQueries","refetchQueries","cancelQuery","cancelQueries","setQueryData","rest","getQueryData","setInfiniteQueryData","getInfiniteQueryData","createClient","dist","BJ","useUtils","useQuery","defaultOpts","getQueryDefaults","ssr","ssrOpts","shouldAbortOnUnmount","hook","actualOpts","queryFunctionContext","useQueries","queriesCallback","_opts","queryOption","defaultedQueries","suspensePromises","shouldAtLeastOneSuspend","queryObserver","all","observerQueries","_defaultedQueries$ind","_defaultedQueries$ind2","firstSingleResultWhichShouldThrow","NL","actualPath","getMutationDefaults","useSubscription","yF","optsRef","isStopped","useDehydratedState","trpcState","useInfiniteQuery","initialCursor","Bm","utilName","getOpts","input1","rest1","contextMap","fetchInfinite","prefetchInfinite","ensureData","invalidate","setData","setInfiniteData","getData","getInfiniteData","lastArg","hooks","opts1","invert","newObj","create","codes_c924c3db_TRPC_ERROR_CODES_BY_KEY","PARSE_ERROR","BAD_REQUEST","INTERNAL_SERVER_ERROR","NOT_IMPLEMENTED","UNAUTHORIZED","FORBIDDEN","NOT_FOUND","METHOD_NOT_SUPPORTED","TIMEOUT","CONFLICT","PRECONDITION_FAILED","PAYLOAD_TOO_LARGE","UNPROCESSABLE_CONTENT","TOO_MANY_REQUESTS","CLIENT_CLOSED_REQUEST","createRecursiveProxy","createInnerProxy","Proxy","_obj","apply","_1","_2","isApply","createFlatProxy","UnknownCauseError","getCauseFromUnknown"],"sourceRoot":""}